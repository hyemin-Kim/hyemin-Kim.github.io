{"meta":{"title":"Hyemin Kim","subtitle":"김혜민 / 金慧敏","description":"","author":"Hyemin Kim","url":"https://hyemin-kim.github.io","root":"/"},"pages":[{"title":"","date":"2020-05-04T18:01:24.474Z","updated":"2020-05-04T18:01:24.474Z","comments":false,"path":"about/index.html","permalink":"https://hyemin-kim.github.io/about/index.html","excerpt":"","text":"Hello document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-05-20T10:31:42.690Z","updated":"2020-05-04T13:34:00.910Z","comments":false,"path":"categories/index - default.html","permalink":"https://hyemin-kim.github.io/categories/index%20-%20default.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"Categories","date":"2020-04-30T15:00:00.000Z","updated":"2020-05-21T11:27:57.020Z","comments":false,"path":"categories/index.html","permalink":"https://hyemin-kim.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"","date":"2020-05-20T08:48:36.782Z","updated":"2020-05-04T13:34:13.986Z","comments":false,"path":"tags/index - default.html","permalink":"https://hyemin-kim.github.io/tags/index%20-%20default.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tagcloud","date":"2020-05-08T05:30:56.000Z","updated":"2020-05-08T05:34:14.280Z","comments":false,"path":"tagcloud/index.html","permalink":"https://hyemin-kim.github.io/tagcloud/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"Links","date":"2020-05-20T08:53:04.000Z","updated":"2020-05-21T11:40:00.304Z","comments":false,"path":"link/index.html","permalink":"https://hyemin-kim.github.io/link/index.html","excerpt":"","text":"Some Useful Links Github Hexo Themes Hexo Usage Hexo Plugins document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"Tag Cloud","date":"2020-04-30T15:00:00.000Z","updated":"2020-05-21T14:01:11.233Z","comments":false,"path":"tags/index.html","permalink":"https://hyemin-kim.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"【실습】 Python >> Pandas 전처리 -- 부동산 데이터","slug":"E-Python-Pandas-Pre-1","date":"2020-06-22T10:14:57.000Z","updated":"2020-06-23T15:16:05.366Z","comments":true,"path":"2020/06/22/E-Python-Pandas-Pre-1/","link":"","permalink":"https://hyemin-kim.github.io/2020/06/22/E-Python-Pandas-Pre-1/","excerpt":"","text":"&lt;Pandas 전처리&gt; 실습 – 부동산 데이터 0. 샘플데이터 1. column 이름 제정의 (rename) 2. Data Overview 2-1. Data Shape 확인하기 2-2. 걸측값과 Data Type 확인하기 2-3. 통계값 확인하기 3. 데이터 타입 변환 3-1. str.strip()을 활용하여 공백이 있는 데이터의 공백 없애기 3-2. 빈 공백에 0을 넣어주기 3-3. NaN 값은 fillna로 채워주기 3-4. str.replace() 를 활용하여 콤마를 제거하기 3-5. str.replace()를 활용하여 “-” 제거하기 3-6. 규모구분 column에 불필요한 “전용면적” 제거하기 4. 전처리 내용 복습하기 5. 지역별 분양가격을 확인해보기 5-1. 지역별 평균 분양가격 확인해보기 5-2. 분양가격이 100보다 작은 행을 제거해보기 5-3. 지역별 “분양가격” 데이터의 갯수를 확인해보기 5-4. 지역별 제일 비싼 분양가를 확인해보기 6. 연도별 평균 분양가격을 확인해보기 7. 피벗테이블 활용하기 8. 연도별, 규모별 가격을 알아보기 1import pandas as pd 0. 샘플데이터 공공데이터포털 에서 제공하는 공공데이터 “민간 아파트 가격동향” 를 활용한다. 1df = pd.read_csv(\"seoul_house_price.csv\") 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격(㎡) 0 서울 전체 2015 10 5841 1 서울 전용면적 60㎡이하 2015 10 5652 2 서울 전용면적 60㎡초과 85㎡이하 2015 10 5882 3 서울 전용면적 85㎡초과 102㎡이하 2015 10 5721 4 서울 전용면적 102㎡초과 2015 10 5879 ... ... ... ... ... ... 4500 제주 전체 2020 2 3955 4501 제주 전용면적 60㎡이하 2020 2 4039 4502 제주 전용면적 60㎡초과 85㎡이하 2020 2 3962 4503 제주 전용면적 85㎡초과 102㎡이하 2020 2 NaN 4504 제주 전용면적 102㎡초과 2020 2 3601 4505 rows × 5 columns 1. column 이름 제정의 (rename) [목표] 분양가격 column의 이름을 재정의: “분양가격(m2)​” --&gt; “분양가격” 1df = df.rename(columns = {\"분양가격(㎡)\" : \"분양가격\"}) 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 0 서울 전체 2015 10 5841 1 서울 전용면적 60㎡이하 2015 10 5652 2 서울 전용면적 60㎡초과 85㎡이하 2015 10 5882 3 서울 전용면적 85㎡초과 102㎡이하 2015 10 5721 4 서울 전용면적 102㎡초과 2015 10 5879 ... ... ... ... ... ... 4500 제주 전체 2020 2 3955 4501 제주 전용면적 60㎡이하 2020 2 4039 4502 제주 전용면적 60㎡초과 85㎡이하 2020 2 3962 4503 제주 전용면적 85㎡초과 102㎡이하 2020 2 NaN 4504 제주 전용면적 102㎡초과 2020 2 3601 4505 rows × 5 columns 2. Data Overview 2-1. Data Shape 확인하기 1df.shape (4505, 5) 2-2. 걸측값과 Data Type 확인하기 1df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 4505 entries, 0 to 4504 Data columns (total 5 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 지역명 4505 non-null object 1 규모구분 4505 non-null object 2 연도 4505 non-null int64 3 월 4505 non-null int64 4 분양가격 4210 non-null object dtypes: int64(2), object(3) memory usage: 176.1+ KB 2-3. 통계값 확인하기 1df.describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 연도 월 count 4505.000000 4505.000000 mean 2017.452830 6.566038 std 1.311432 3.595519 min 2015.000000 1.000000 25% 2016.000000 3.000000 50% 2017.000000 7.000000 75% 2019.000000 10.000000 max 2020.000000 12.000000 3. 데이터 타입 변환 [목표] &lt;object 타입&gt;으로 되어있는 \"분양가격\"을 &lt;int 타입&gt;으로 변환하기 1df[\"분양가격\"].astype(int) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-193-5870dcdf031c&gt; in &lt;module&gt; ----&gt; 1 df[\"분양가격\"].astype(int) D:\\Anaconda\\lib\\site-packages\\pandas\\core\\generic.py in astype(self, dtype, copy, errors) 5696 else: 5697 # else, only a single dtype is given -&gt; 5698 new_data = self._data.astype(dtype=dtype, copy=copy, errors=errors) 5699 return self._constructor(new_data).__finalize__(self) 5700 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\managers.py in astype(self, dtype, copy, errors) 580 581 def astype(self, dtype, copy: bool = False, errors: str = \"raise\"): --&gt; 582 return self.apply(\"astype\", dtype=dtype, copy=copy, errors=errors) 583 584 def convert(self, **kwargs): D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\managers.py in apply(self, f, filter, **kwargs) 440 applied = b.apply(f, **kwargs) 441 else: --&gt; 442 applied = getattr(b, f)(**kwargs) 443 result_blocks = _extend_blocks(applied, result_blocks) 444 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\blocks.py in astype(self, dtype, copy, errors) 623 vals1d = values.ravel() 624 try: --&gt; 625 values = astype_nansafe(vals1d, dtype, copy=True) 626 except (ValueError, TypeError): 627 # e.g. astype_nansafe can fail on object-dtype of strings D:\\Anaconda\\lib\\site-packages\\pandas\\core\\dtypes\\cast.py in astype_nansafe(arr, dtype, copy, skipna) 872 # work around NumPy brokenness, #1987 873 if np.issubdtype(dtype.type, np.integer): --&gt; 874 return lib.astype_intsafe(arr.ravel(), dtype).reshape(arr.shape) 875 876 # if we have a datetime/timedelta array of objects pandas\\_libs\\lib.pyx in pandas._libs.lib.astype_intsafe() ValueError: invalid literal for int() with base 10: ' ' !! “분양가격” column에 “2칸 공백” 값이 있어서 Error가 납니다 3-1. str.strip()을 활용하여 공백이 있는 데이터의 공백 없애기 df_name [ “col_name” ] .str.strip() 1df.loc[df[\"분양가격\"] == ' '] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 28 광주 전용면적 85㎡초과 102㎡이하 2015 10 29 광주 전용면적 102㎡초과 2015 10 34 대전 전용면적 102㎡초과 2015 10 81 제주 전용면적 60㎡이하 2015 10 113 광주 전용면적 85㎡초과 102㎡이하 2015 11 114 광주 전용면적 102㎡초과 2015 11 119 대전 전용면적 102㎡초과 2015 11 166 제주 전용면적 60㎡이하 2015 11 198 광주 전용면적 85㎡초과 102㎡이하 2015 12 199 광주 전용면적 102㎡초과 2015 12 204 대전 전용면적 102㎡초과 2015 12 251 제주 전용면적 60㎡이하 2015 12 283 광주 전용면적 85㎡초과 102㎡이하 2016 1 284 광주 전용면적 102㎡초과 2016 1 289 대전 전용면적 102㎡초과 2016 1 336 제주 전용면적 60㎡이하 2016 1 1df[\"분양가격\"] = df[\"분양가격\"].str.strip(' ') 1df.loc[df[\"분양가격\"] == \" \"] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 3-2. 빈 공백에 0을 넣어주기 1df.loc[df[\"분양가격\"] == '', \"분양가격\"] = 0 1df[\"분양가격\"].astype(int) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-198-5870dcdf031c&gt; in &lt;module&gt; ----&gt; 1 df[\"분양가격\"].astype(int) D:\\Anaconda\\lib\\site-packages\\pandas\\core\\generic.py in astype(self, dtype, copy, errors) 5696 else: 5697 # else, only a single dtype is given -&gt; 5698 new_data = self._data.astype(dtype=dtype, copy=copy, errors=errors) 5699 return self._constructor(new_data).__finalize__(self) 5700 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\managers.py in astype(self, dtype, copy, errors) 580 581 def astype(self, dtype, copy: bool = False, errors: str = \"raise\"): --&gt; 582 return self.apply(\"astype\", dtype=dtype, copy=copy, errors=errors) 583 584 def convert(self, **kwargs): D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\managers.py in apply(self, f, filter, **kwargs) 440 applied = b.apply(f, **kwargs) 441 else: --&gt; 442 applied = getattr(b, f)(**kwargs) 443 result_blocks = _extend_blocks(applied, result_blocks) 444 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\blocks.py in astype(self, dtype, copy, errors) 623 vals1d = values.ravel() 624 try: --&gt; 625 values = astype_nansafe(vals1d, dtype, copy=True) 626 except (ValueError, TypeError): 627 # e.g. astype_nansafe can fail on object-dtype of strings D:\\Anaconda\\lib\\site-packages\\pandas\\core\\dtypes\\cast.py in astype_nansafe(arr, dtype, copy, skipna) 872 # work around NumPy brokenness, #1987 873 if np.issubdtype(dtype.type, np.integer): --&gt; 874 return lib.astype_intsafe(arr.ravel(), dtype).reshape(arr.shape) 875 876 # if we have a datetime/timedelta array of objects pandas\\_libs\\lib.pyx in pandas._libs.lib.astype_intsafe() ValueError: cannot convert float NaN to integer !! “분양가격” column에 “NaN” 값이 있어서 Error가 또 납니다 ㅠㅠ 3-3. NaN 값은 fillna로 채워주기 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 0 서울 전체 2015 10 5841 1 서울 전용면적 60㎡이하 2015 10 5652 2 서울 전용면적 60㎡초과 85㎡이하 2015 10 5882 3 서울 전용면적 85㎡초과 102㎡이하 2015 10 5721 4 서울 전용면적 102㎡초과 2015 10 5879 ... ... ... ... ... ... 4500 제주 전체 2020 2 3955 4501 제주 전용면적 60㎡이하 2020 2 4039 4502 제주 전용면적 60㎡초과 85㎡이하 2020 2 3962 4503 제주 전용면적 85㎡초과 102㎡이하 2020 2 NaN 4504 제주 전용면적 102㎡초과 2020 2 3601 4505 rows × 5 columns 1df.loc[df[\"분양가격\"].isna()] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 368 광주 전용면적 85㎡초과 102㎡이하 2016 2 NaN 369 광주 전용면적 102㎡초과 2016 2 NaN 374 대전 전용면적 102㎡초과 2016 2 NaN 388 강원 전용면적 85㎡초과 102㎡이하 2016 2 NaN 421 제주 전용면적 60㎡이하 2016 2 NaN ... ... ... ... ... ... 4461 세종 전용면적 60㎡이하 2020 2 NaN 4488 전남 전용면적 85㎡초과 102㎡이하 2020 2 NaN 4493 경북 전용면적 85㎡초과 102㎡이하 2020 2 NaN 4499 경남 전용면적 102㎡초과 2020 2 NaN 4503 제주 전용면적 85㎡초과 102㎡이하 2020 2 NaN 295 rows × 5 columns 1df[\"분양가격\"] = df[\"분양가격\"].fillna(0) 1df.loc[df[\"분양가격\"].isna()] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 1df[\"분양가격\"].astype(int) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-203-5870dcdf031c&gt; in &lt;module&gt; ----&gt; 1 df[\"분양가격\"].astype(int) D:\\Anaconda\\lib\\site-packages\\pandas\\core\\generic.py in astype(self, dtype, copy, errors) 5696 else: 5697 # else, only a single dtype is given -&gt; 5698 new_data = self._data.astype(dtype=dtype, copy=copy, errors=errors) 5699 return self._constructor(new_data).__finalize__(self) 5700 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\managers.py in astype(self, dtype, copy, errors) 580 581 def astype(self, dtype, copy: bool = False, errors: str = \"raise\"): --&gt; 582 return self.apply(\"astype\", dtype=dtype, copy=copy, errors=errors) 583 584 def convert(self, **kwargs): D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\managers.py in apply(self, f, filter, **kwargs) 440 applied = b.apply(f, **kwargs) 441 else: --&gt; 442 applied = getattr(b, f)(**kwargs) 443 result_blocks = _extend_blocks(applied, result_blocks) 444 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\blocks.py in astype(self, dtype, copy, errors) 623 vals1d = values.ravel() 624 try: --&gt; 625 values = astype_nansafe(vals1d, dtype, copy=True) 626 except (ValueError, TypeError): 627 # e.g. astype_nansafe can fail on object-dtype of strings D:\\Anaconda\\lib\\site-packages\\pandas\\core\\dtypes\\cast.py in astype_nansafe(arr, dtype, copy, skipna) 872 # work around NumPy brokenness, #1987 873 if np.issubdtype(dtype.type, np.integer): --&gt; 874 return lib.astype_intsafe(arr.ravel(), dtype).reshape(arr.shape) 875 876 # if we have a datetime/timedelta array of objects pandas\\_libs\\lib.pyx in pandas._libs.lib.astype_intsafe() ValueError: invalid literal for int() with base 10: '6,657' !! 이번에는 \",\"가 들어간 데이터가 문제네요… 3-4. str.replace() 를 활용하여 콤마를 제거하기 1df.loc[df[\"분양가격\"] == \"6,657\"] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 2125 서울 전체 2017 11 6,657 1df[\"분양가격\"] = df[\"분양가격\"].str.replace(',', '') 1df[\"분양가격\"].astype(int) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-206-5870dcdf031c&gt; in &lt;module&gt; ----&gt; 1 df[\"분양가격\"].astype(int) D:\\Anaconda\\lib\\site-packages\\pandas\\core\\generic.py in astype(self, dtype, copy, errors) 5696 else: 5697 # else, only a single dtype is given -&gt; 5698 new_data = self._data.astype(dtype=dtype, copy=copy, errors=errors) 5699 return self._constructor(new_data).__finalize__(self) 5700 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\managers.py in astype(self, dtype, copy, errors) 580 581 def astype(self, dtype, copy: bool = False, errors: str = \"raise\"): --&gt; 582 return self.apply(\"astype\", dtype=dtype, copy=copy, errors=errors) 583 584 def convert(self, **kwargs): D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\managers.py in apply(self, f, filter, **kwargs) 440 applied = b.apply(f, **kwargs) 441 else: --&gt; 442 applied = getattr(b, f)(**kwargs) 443 result_blocks = _extend_blocks(applied, result_blocks) 444 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\blocks.py in astype(self, dtype, copy, errors) 623 vals1d = values.ravel() 624 try: --&gt; 625 values = astype_nansafe(vals1d, dtype, copy=True) 626 except (ValueError, TypeError): 627 # e.g. astype_nansafe can fail on object-dtype of strings D:\\Anaconda\\lib\\site-packages\\pandas\\core\\dtypes\\cast.py in astype_nansafe(arr, dtype, copy, skipna) 872 # work around NumPy brokenness, #1987 873 if np.issubdtype(dtype.type, np.integer): --&gt; 874 return lib.astype_intsafe(arr.ravel(), dtype).reshape(arr.shape) 875 876 # if we have a datetime/timedelta array of objects pandas\\_libs\\lib.pyx in pandas._libs.lib.astype_intsafe() ValueError: cannot convert float NaN to integer !! 다시 NaN값이 생겨서 fillna로 채워줍니다. 1df[\"분양가격\"] = df[\"분양가격\"].fillna(0) 1df[\"분양가격\"].astype(int) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-208-5870dcdf031c&gt; in &lt;module&gt; ----&gt; 1 df[\"분양가격\"].astype(int) D:\\Anaconda\\lib\\site-packages\\pandas\\core\\generic.py in astype(self, dtype, copy, errors) 5696 else: 5697 # else, only a single dtype is given -&gt; 5698 new_data = self._data.astype(dtype=dtype, copy=copy, errors=errors) 5699 return self._constructor(new_data).__finalize__(self) 5700 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\managers.py in astype(self, dtype, copy, errors) 580 581 def astype(self, dtype, copy: bool = False, errors: str = \"raise\"): --&gt; 582 return self.apply(\"astype\", dtype=dtype, copy=copy, errors=errors) 583 584 def convert(self, **kwargs): D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\managers.py in apply(self, f, filter, **kwargs) 440 applied = b.apply(f, **kwargs) 441 else: --&gt; 442 applied = getattr(b, f)(**kwargs) 443 result_blocks = _extend_blocks(applied, result_blocks) 444 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\blocks.py in astype(self, dtype, copy, errors) 623 vals1d = values.ravel() 624 try: --&gt; 625 values = astype_nansafe(vals1d, dtype, copy=True) 626 except (ValueError, TypeError): 627 # e.g. astype_nansafe can fail on object-dtype of strings D:\\Anaconda\\lib\\site-packages\\pandas\\core\\dtypes\\cast.py in astype_nansafe(arr, dtype, copy, skipna) 872 # work around NumPy brokenness, #1987 873 if np.issubdtype(dtype.type, np.integer): --&gt; 874 return lib.astype_intsafe(arr.ravel(), dtype).reshape(arr.shape) 875 876 # if we have a datetime/timedelta array of objects pandas\\_libs\\lib.pyx in pandas._libs.lib.astype_intsafe() ValueError: invalid literal for int() with base 10: '-' !! 이번에는 \"-\"가 멀썽이네요… 3-5. str.replace()를 활용하여 “-” 제거하기 1df[\"분양가격\"] = df[\"분양가격\"].str.replace(\"-\", \"\") 1df.loc[df[\"분양가격\"] == \"\", \"분양가격\"] = 0 1df[\"분양가격\"].astype(int) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-211-5870dcdf031c&gt; in &lt;module&gt; ----&gt; 1 df[\"분양가격\"].astype(int) D:\\Anaconda\\lib\\site-packages\\pandas\\core\\generic.py in astype(self, dtype, copy, errors) 5696 else: 5697 # else, only a single dtype is given -&gt; 5698 new_data = self._data.astype(dtype=dtype, copy=copy, errors=errors) 5699 return self._constructor(new_data).__finalize__(self) 5700 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\managers.py in astype(self, dtype, copy, errors) 580 581 def astype(self, dtype, copy: bool = False, errors: str = \"raise\"): --&gt; 582 return self.apply(\"astype\", dtype=dtype, copy=copy, errors=errors) 583 584 def convert(self, **kwargs): D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\managers.py in apply(self, f, filter, **kwargs) 440 applied = b.apply(f, **kwargs) 441 else: --&gt; 442 applied = getattr(b, f)(**kwargs) 443 result_blocks = _extend_blocks(applied, result_blocks) 444 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\blocks.py in astype(self, dtype, copy, errors) 623 vals1d = values.ravel() 624 try: --&gt; 625 values = astype_nansafe(vals1d, dtype, copy=True) 626 except (ValueError, TypeError): 627 # e.g. astype_nansafe can fail on object-dtype of strings D:\\Anaconda\\lib\\site-packages\\pandas\\core\\dtypes\\cast.py in astype_nansafe(arr, dtype, copy, skipna) 872 # work around NumPy brokenness, #1987 873 if np.issubdtype(dtype.type, np.integer): --&gt; 874 return lib.astype_intsafe(arr.ravel(), dtype).reshape(arr.shape) 875 876 # if we have a datetime/timedelta array of objects pandas\\_libs\\lib.pyx in pandas._libs.lib.astype_intsafe() ValueError: cannot convert float NaN to integer 1df[\"분양가격\"] = df[\"분양가격\"].fillna(0) 1df[\"분양가격\"] = df[\"분양가격\"].astype(int) 1df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 4505 entries, 0 to 4504 Data columns (total 5 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 지역명 4505 non-null object 1 규모구분 4505 non-null object 2 연도 4505 non-null int64 3 월 4505 non-null int64 4 분양가격 4505 non-null int32 dtypes: int32(1), int64(2), object(2) memory usage: 158.5+ KB 이제 드디어 “분양가격” column의 Type을 int로 성공적으로 바꿨습니다!!! 3-6. 규모구분 column에 불필요한 “전용면적” 제거하기 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 0 서울 전체 2015 10 5841 1 서울 전용면적 60㎡이하 2015 10 5652 2 서울 전용면적 60㎡초과 85㎡이하 2015 10 5882 3 서울 전용면적 85㎡초과 102㎡이하 2015 10 5721 4 서울 전용면적 102㎡초과 2015 10 5879 1df[\"규모구분\"] = df[\"규모구분\"].str.replace(\"전용면적\", \"\") 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 0 서울 전체 2015 10 5841 1 서울 60㎡이하 2015 10 5652 2 서울 60㎡초과 85㎡이하 2015 10 5882 3 서울 85㎡초과 102㎡이하 2015 10 5721 4 서울 102㎡초과 2015 10 5879 4. 전처리 내용 복습하기 방급 진행 했던 전처리 과정을 복습해봅시다! 1df2 = pd.read_csv(\"seoul_house_price.csv\") (1) 콤마가 있는 경우 df_name [ “col_name” ] .str.replace (’,’, ‘’) 1df2.iloc[2125] 지역명 서울 규모구분 전체 연도 2017 월 11 분양가격(㎡) 6,657 Name: 2125, dtype: object 1df2 = df2.rename(columns = {\"분양가격(㎡)\" : \"분양가격\"}) 1df2[\"분양가격\"] = df2[\"분양가격\"].str.replace(\",\", \"\") 1df2.iloc[2125] 지역명 서울 규모구분 전체 연도 2017 월 11 분양가격 6657 Name: 2125, dtype: object (2) - 가 있는 경우 df_name [ “col_name” ] **.str.replace(’-’, ‘’) 1df2.loc[df2[\"분양가격\"] == \"-\"] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 3683 광주 전용면적 85㎡초과 102㎡이하 2019 5 - 3686 대전 전용면적 60㎡이하 2019 5 - 3688 대전 전용면적 85㎡초과 102㎡이하 2019 5 - 3690 울산 전체 2019 5 - 3691 울산 전용면적 60㎡이하 2019 5 - 3692 울산 전용면적 60㎡초과 85㎡이하 2019 5 - 3693 울산 전용면적 85㎡초과 102㎡이하 2019 5 - 3694 울산 전용면적 102㎡초과 2019 5 - 3696 세종 전용면적 60㎡이하 2019 5 - 1df2[\"분양가격\"] = df2[\"분양가격\"].str.replace(\"-\", \"\") 1df2.loc[df2[\"분양가격\"] == \"-\"] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 (3) 공백이 2개 들어간 경우 df_name [ “col_name” ] **.str.strip(\" \") 1df2.loc[df2[\"분양가격\"] == \" \"] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 28 광주 전용면적 85㎡초과 102㎡이하 2015 10 29 광주 전용면적 102㎡초과 2015 10 34 대전 전용면적 102㎡초과 2015 10 81 제주 전용면적 60㎡이하 2015 10 113 광주 전용면적 85㎡초과 102㎡이하 2015 11 114 광주 전용면적 102㎡초과 2015 11 119 대전 전용면적 102㎡초과 2015 11 166 제주 전용면적 60㎡이하 2015 11 198 광주 전용면적 85㎡초과 102㎡이하 2015 12 199 광주 전용면적 102㎡초과 2015 12 204 대전 전용면적 102㎡초과 2015 12 251 제주 전용면적 60㎡이하 2015 12 283 광주 전용면적 85㎡초과 102㎡이하 2016 1 284 광주 전용면적 102㎡초과 2016 1 289 대전 전용면적 102㎡초과 2016 1 336 제주 전용면적 60㎡이하 2016 1 1df2[\"분양가격\"] = df2[\"분양가격\"].str.strip(\" \") 1df2.loc[df2[\"분양가격\"] == \" \"] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 (4) 빈 칸을 0으로 채우기 df_name.loc [ df_name [ “col_name” ] == “” , “col_name”] = 0 1df2.loc[df2[\"분양가격\"] == \"\"] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 28 광주 전용면적 85㎡초과 102㎡이하 2015 10 29 광주 전용면적 102㎡초과 2015 10 34 대전 전용면적 102㎡초과 2015 10 81 제주 전용면적 60㎡이하 2015 10 113 광주 전용면적 85㎡초과 102㎡이하 2015 11 114 광주 전용면적 102㎡초과 2015 11 119 대전 전용면적 102㎡초과 2015 11 166 제주 전용면적 60㎡이하 2015 11 198 광주 전용면적 85㎡초과 102㎡이하 2015 12 199 광주 전용면적 102㎡초과 2015 12 204 대전 전용면적 102㎡초과 2015 12 251 제주 전용면적 60㎡이하 2015 12 283 광주 전용면적 85㎡초과 102㎡이하 2016 1 284 광주 전용면적 102㎡초과 2016 1 289 대전 전용면적 102㎡초과 2016 1 336 제주 전용면적 60㎡이하 2016 1 3683 광주 전용면적 85㎡초과 102㎡이하 2019 5 3686 대전 전용면적 60㎡이하 2019 5 3688 대전 전용면적 85㎡초과 102㎡이하 2019 5 3690 울산 전체 2019 5 3691 울산 전용면적 60㎡이하 2019 5 3692 울산 전용면적 60㎡초과 85㎡이하 2019 5 3693 울산 전용면적 85㎡초과 102㎡이하 2019 5 3694 울산 전용면적 102㎡초과 2019 5 3696 세종 전용면적 60㎡이하 2019 5 1df2.loc[df2[\"분양가격\"] == \"\", \"분양가격\"] = 0 1df2.loc[df2[\"분양가격\"] == \"\"] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 (5) NaN 값을 0으로 바꾸기 df_name.loc [ df_name [ “col_name” ] .isna() ] df_name [ “col_name” ].fillna(0) 1df2.loc[df2[\"분양가격\"].isna()] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 368 광주 전용면적 85㎡초과 102㎡이하 2016 2 NaN 369 광주 전용면적 102㎡초과 2016 2 NaN 374 대전 전용면적 102㎡초과 2016 2 NaN 388 강원 전용면적 85㎡초과 102㎡이하 2016 2 NaN 421 제주 전용면적 60㎡이하 2016 2 NaN ... ... ... ... ... ... 4461 세종 전용면적 60㎡이하 2020 2 NaN 4488 전남 전용면적 85㎡초과 102㎡이하 2020 2 NaN 4493 경북 전용면적 85㎡초과 102㎡이하 2020 2 NaN 4499 경남 전용면적 102㎡초과 2020 2 NaN 4503 제주 전용면적 85㎡초과 102㎡이하 2020 2 NaN 295 rows × 5 columns 1df2[\"분양가격\"] = df2[\"분양가격\"].fillna(0) 1df2.loc[df2[\"분양가격\"].isna()] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 (6) column type 바꾸기 df_name [ “col_name” ] .astype(…) 1df2[\"분양가격\"].astype(int) 0 5841 1 5652 2 5882 3 5721 4 5879 ... 4500 3955 4501 4039 4502 3962 4503 0 4504 3601 Name: 분양가격, Length: 4505, dtype: int32 5. 지역별 분양가격을 확인해보기 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 0 서울 전체 2015 10 5841 1 서울 60㎡이하 2015 10 5652 2 서울 60㎡초과 85㎡이하 2015 10 5882 3 서울 85㎡초과 102㎡이하 2015 10 5721 4 서울 102㎡초과 2015 10 5879 ... ... ... ... ... ... 4500 제주 전체 2020 2 3955 4501 제주 60㎡이하 2020 2 4039 4502 제주 60㎡초과 85㎡이하 2020 2 3962 4503 제주 85㎡초과 102㎡이하 2020 2 0 4504 제주 102㎡초과 2020 2 3601 4505 rows × 5 columns 1df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 4505 entries, 0 to 4504 Data columns (total 5 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 지역명 4505 non-null object 1 규모구분 4505 non-null object 2 연도 4505 non-null int64 3 월 4505 non-null int64 4 분양가격 4505 non-null int32 dtypes: int32(1), int64(2), object(2) memory usage: 158.5+ KB 5-1. 지역별 평균 분양가격 확인해보기 1df.groupby(\"지역명\")[\"분양가격\"].mean() 지역명 강원 2339.807547 경기 4072.667925 경남 2761.275472 경북 2432.128302 광주 2450.728302 대구 3538.920755 대전 2479.135849 부산 3679.920755 서울 7225.762264 세종 2815.098113 울산 1826.101887 인천 3578.433962 전남 2270.177358 전북 2322.060377 제주 2979.407547 충남 2388.324528 충북 2316.871698 Name: 분양가격, dtype: float64 5-2. 분양가격이 100보다 작은 행을 제거해보기 특정 조건에 만족하는 행을 제거하고자 할 때는 index를 list로 가져온다 idx = df.loc [ 조건식 ] .index drop을 활용하여 행을 제거한다 df_name = df_name .drop (idx, axis = 0) 1idx = df.loc[df[\"분양가격\"] &lt; 100].index 1idx Int64Index([ 28, 29, 34, 81, 113, 114, 119, 166, 198, 199, ... 4418, 4448, 4453, 4458, 4459, 4461, 4488, 4493, 4499, 4503], dtype='int64', length=320) 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 0 서울 전체 2015 10 5841 1 서울 60㎡이하 2015 10 5652 2 서울 60㎡초과 85㎡이하 2015 10 5882 3 서울 85㎡초과 102㎡이하 2015 10 5721 4 서울 102㎡초과 2015 10 5879 ... ... ... ... ... ... 4500 제주 전체 2020 2 3955 4501 제주 60㎡이하 2020 2 4039 4502 제주 60㎡초과 85㎡이하 2020 2 3962 4503 제주 85㎡초과 102㎡이하 2020 2 0 4504 제주 102㎡초과 2020 2 3601 4505 rows × 5 columns 1df = df.drop(idx, axis = 0) 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 0 서울 전체 2015 10 5841 1 서울 60㎡이하 2015 10 5652 2 서울 60㎡초과 85㎡이하 2015 10 5882 3 서울 85㎡초과 102㎡이하 2015 10 5721 4 서울 102㎡초과 2015 10 5879 ... ... ... ... ... ... 4498 경남 85㎡초과 102㎡이하 2020 2 3247 4500 제주 전체 2020 2 3955 4501 제주 60㎡이하 2020 2 4039 4502 제주 60㎡초과 85㎡이하 2020 2 3962 4504 제주 102㎡초과 2020 2 3601 4185 rows × 5 columns 다시 한 번 지역명으로 group을 묶어 분양가격을 확인해보자! 1df.groupby(\"지역명\")[\"분양가격\"].mean() 지역명 강원 2412.642023 경기 4072.667925 경남 2814.376923 경북 2547.486166 광주 3049.028169 대구 3663.335938 대전 3128.433333 부산 3679.920755 서울 7225.762264 세종 2984.004000 울산 3043.503145 인천 3633.275862 전남 2304.969349 전북 2348.648855 제주 3432.795652 충남 2501.604743 충북 2316.871698 Name: 분양가격, dtype: float64 5-3. 지역별 “분양가격” 데이터의 갯수를 확인해보기 1df.groupby(\"지역명\")[\"분양가격\"].count() 지역명 강원 257 경기 265 경남 260 경북 253 광주 213 대구 256 대전 210 부산 265 서울 265 세종 250 울산 159 인천 261 전남 261 전북 262 제주 230 충남 253 충북 265 Name: 분양가격, dtype: int64 5-4. 지역별 제일 비싼 분양가를 확인해보기 1df.groupby(\"지역명\")[\"분양가격\"].max() 지역명 강원 3906 경기 5670 경남 4303 경북 3457 광주 4881 대구 5158 대전 4877 부산 4623 서울 13835 세종 3931 울산 3594 인천 5188 전남 3053 전북 3052 제주 5462 충남 3201 충북 2855 Name: 분양가격, dtype: int32 6. 연도별 평균 분양가격을 확인해보기 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 0 서울 전체 2015 10 5841 1 서울 60㎡이하 2015 10 5652 2 서울 60㎡초과 85㎡이하 2015 10 5882 3 서울 85㎡초과 102㎡이하 2015 10 5721 4 서울 102㎡초과 2015 10 5879 1df.groupby(\"연도\")[\"분양가격\"].mean() 연도 2015 2788.707819 2016 2934.250000 2017 3143.311795 2018 3326.951034 2019 3693.422149 2020 3853.960526 Name: 분양가격, dtype: float64 7. 피벗테이블 활용하기 행 인덱스: 연도 열 인덱스: 규모구분 값: 분양가 (평균) 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 지역명 규모구분 연도 월 분양가격 0 서울 전체 2015 10 5841 1 서울 60㎡이하 2015 10 5652 2 서울 60㎡초과 85㎡이하 2015 10 5882 3 서울 85㎡초과 102㎡이하 2015 10 5721 4 서울 102㎡초과 2015 10 5879 1pd.pivot_table(df, index = \"연도\", columns = \"규모구분\", values = \"분양가격\") .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 규모구분 102㎡초과 60㎡이하 60㎡초과 85㎡이하 85㎡초과 102㎡이하 전체 연도 2015 2980.977778 2712.583333 2694.490196 2884.395833 2694.862745 2016 3148.099476 2848.144279 2816.965686 3067.380435 2816.073529 2017 3427.649746 3112.538071 2981.950980 3204.075145 3008.279412 2018 3468.355932 3286.184783 3227.458128 3467.184211 3235.098522 2019 4039.854839 3486.910112 3538.545918 3933.538462 3515.974490 2020 4187.566667 3615.968750 3594.852941 4532.090909 3603.911765 8. 연도별, 규모별 가격을 알아보기 1df.groupby([\"연도\", \"규모구분\"])[\"분양가격\"].mean() 연도 규모구분 2015 102㎡초과 2980.977778 60㎡이하 2712.583333 60㎡초과 85㎡이하 2694.490196 85㎡초과 102㎡이하 2884.395833 전체 2694.862745 2016 102㎡초과 3148.099476 60㎡이하 2848.144279 60㎡초과 85㎡이하 2816.965686 85㎡초과 102㎡이하 3067.380435 전체 2816.073529 2017 102㎡초과 3427.649746 60㎡이하 3112.538071 60㎡초과 85㎡이하 2981.950980 85㎡초과 102㎡이하 3204.075145 전체 3008.279412 2018 102㎡초과 3468.355932 60㎡이하 3286.184783 60㎡초과 85㎡이하 3227.458128 85㎡초과 102㎡이하 3467.184211 전체 3235.098522 2019 102㎡초과 4039.854839 60㎡이하 3486.910112 60㎡초과 85㎡이하 3538.545918 85㎡초과 102㎡이하 3933.538462 전체 3515.974490 2020 102㎡초과 4187.566667 60㎡이하 3615.968750 60㎡초과 85㎡이하 3594.852941 85㎡초과 102㎡이하 4532.090909 전체 3603.911765 Name: 분양가격, dtype: float64 예쁘게 출력이 안되어서 보기가 힘들때는 pd.DataFrame()으로 한 번 더 감싸주면 됩니다. 1pd.DataFrame(df.groupby([\"연도\", \"규모구분\"])[\"분양가격\"].mean()) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 분양가격 연도 규모구분 2015 102㎡초과 2980.977778 60㎡이하 2712.583333 60㎡초과 85㎡이하 2694.490196 85㎡초과 102㎡이하 2884.395833 전체 2694.862745 2016 102㎡초과 3148.099476 60㎡이하 2848.144279 60㎡초과 85㎡이하 2816.965686 85㎡초과 102㎡이하 3067.380435 전체 2816.073529 2017 102㎡초과 3427.649746 60㎡이하 3112.538071 60㎡초과 85㎡이하 2981.950980 85㎡초과 102㎡이하 3204.075145 전체 3008.279412 2018 102㎡초과 3468.355932 60㎡이하 3286.184783 60㎡초과 85㎡이하 3227.458128 85㎡초과 102㎡이하 3467.184211 전체 3235.098522 2019 102㎡초과 4039.854839 60㎡이하 3486.910112 60㎡초과 85㎡이하 3538.545918 85㎡초과 102㎡이하 3933.538462 전체 3515.974490 2020 102㎡초과 4187.566667 60㎡이하 3615.968750 60㎡초과 85㎡이하 3594.852941 85㎡초과 102㎡이하 4532.090909 전체 3603.911765 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Exercise】","slug":"【Exercise】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Exercise%E3%80%91/"},{"name":"Python","slug":"【Exercise】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Exercise%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hyemin-kim.github.io/tags/Pandas/"},{"name":"전처리","slug":"전처리","permalink":"https://hyemin-kim.github.io/tags/%EC%A0%84%EC%B2%98%EB%A6%AC/"}]},{"title":"Python >> Pandas 전처리 - (7) 기타","slug":"S-Python-Pandas-Pre7","date":"2020-06-20T13:28:42.000Z","updated":"2020-06-22T10:39:41.237Z","comments":true,"path":"2020/06/20/S-Python-Pandas-Pre7/","link":"","permalink":"https://hyemin-kim.github.io/2020/06/20/S-Python-Pandas-Pre7/","excerpt":"","text":"기타 1. 데이터 타입별 column 선택 (select_dtypes) 문자열이 있는 column만 선택 / 배제 2. One-hot-encoding (원핫인코딩) 1import pandas as pd 1df = pd.read_csv(\"korean-idol.csv\") 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1. 데이터 타입별 column 선택 (select_dtypes) 1df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 15 entries, 0 to 14 Data columns (total 8 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 이름 15 non-null object 1 그룹 14 non-null object 2 소속사 15 non-null object 3 성별 15 non-null object 4 생년월일 15 non-null object 5 키 13 non-null float64 6 혈액형 15 non-null object 7 브랜드평판지수 15 non-null int64 dtypes: float64(1), int64(1), object(6) memory usage: 1.1+ KB 문자열이 있는 column만 선택 / 배제 df_name .select_dtypes (include = ‘object’) df_name .select_dtypes (exclude = ‘object’) (1) 문자열 column만 선택 1df.select_dtypes(include = 'object') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 혈액형 0 지민 방탄소년단 빅히트 남자 1995-10-13 A 1 지드래곤 빅뱅 YG 남자 1988-08-18 A 2 강다니엘 NaN 커넥트 남자 1996-12-10 A 3 뷔 방탄소년단 빅히트 남자 1995-12-30 AB 4 화사 마마무 RBW 여자 1995-07-23 A 5 정국 방탄소년단 빅히트 남자 1997-09-01 A 6 민현 뉴이스트 플레디스 남자 1995-08-09 O 7 소연 아이들 큐브 여자 1998-08-26 B 8 진 방탄소년단 빅히트 남자 1992-12-04 O 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 A 10 태연 소녀시대 SM 여자 1989-03-09 A 11 차은우 아스트로 판타지오 남자 1997-03-30 B 12 백호 뉴이스트 플레디스 남자 1995-07-21 AB 13 JR 뉴이스트 플레디스 남자 1995-06-08 O 14 슈가 방탄소년단 빅히트 남자 1993-03-09 O (2) 문자열 column 배제 (문자열이 아닌 column만 선택) 1df.select_dtypes(exclude = 'object') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 키 브랜드평판지수 0 173.6 10523260 1 177.0 9916947 2 180.0 8273745 3 178.0 8073501 4 162.1 7650928 5 178.0 5208335 6 182.3 4989792 7 NaN 4668615 8 179.2 4570308 9 167.1 4036489 10 NaN 3918661 11 183.0 3506027 12 175.0 3301654 13 176.0 3274137 14 174.0 2925442 문자열이 포함된 DataFrame의 연산으로 발생되는 Error문제는 이 방법을 이용하여 해결할 수 있다 1df + 10 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) D:\\Anaconda\\lib\\site-packages\\pandas\\core\\ops\\array_ops.py in na_arithmetic_op(left, right, op, str_rep) 148 try: --&gt; 149 result = expressions.evaluate(op, str_rep, left, right) 150 except TypeError: D:\\Anaconda\\lib\\site-packages\\pandas\\core\\computation\\expressions.py in evaluate(op, op_str, a, b, use_numexpr) 207 if use_numexpr: --&gt; 208 return _evaluate(op, op_str, a, b) 209 return _evaluate_standard(op, op_str, a, b) D:\\Anaconda\\lib\\site-packages\\pandas\\core\\computation\\expressions.py in _evaluate_numexpr(op, op_str, a, b) 120 if result is None: --&gt; 121 result = _evaluate_standard(op, op_str, a, b) 122 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\computation\\expressions.py in _evaluate_standard(op, op_str, a, b) 69 with np.errstate(all=\"ignore\"): ---&gt; 70 return op(a, b) 71 TypeError: can only concatenate str (not \"int\") to str ​ 1df.select_dtypes(exclude = 'object') + 10 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 키 브랜드평판지수 0 183.6 10523270 1 187.0 9916957 2 190.0 8273755 3 188.0 8073511 4 172.1 7650938 5 188.0 5208345 6 192.3 4989802 7 NaN 4668625 8 189.2 4570318 9 177.1 4036499 10 NaN 3918671 11 193.0 3506037 12 185.0 3301664 13 186.0 3274147 14 184.0 2925452 (3) “문자열 column” / “비문자열 column” 의 column명을 추출 1df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 15 entries, 0 to 14 Data columns (total 8 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 이름 15 non-null object 1 그룹 14 non-null object 2 소속사 15 non-null object 3 성별 15 non-null object 4 생년월일 15 non-null object 5 키 13 non-null float64 6 혈액형 15 non-null object 7 브랜드평판지수 15 non-null int64 dtypes: float64(1), int64(1), object(6) memory usage: 1.1+ KB 12obj_cols = df.select_dtypes(include = 'object').columnsobj_cols Index(['이름', '그룹', '소속사', '성별', '생년월일', '혈액형'], dtype='object') 12num_cols = df.select_dtypes(exclude = 'object').columnsnum_cols Index(['키', '브랜드평판지수'], dtype='object') 1df[num_cols] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 키 브랜드평판지수 0 173.6 10523260 1 177.0 9916947 2 180.0 8273745 3 178.0 8073501 4 162.1 7650928 5 178.0 5208335 6 182.3 4989792 7 NaN 4668615 8 179.2 4570308 9 167.1 4036489 10 NaN 3918661 11 183.0 3506027 12 175.0 3301654 13 176.0 3274137 14 174.0 2925442 2. One-hot-encoding (원핫인코딩) One-hot-encoding: Categorical data를 dummy data로 변환시키는 방법 Dummy data로 변환 시 한개의 요소는 True (1) 로, 나머지 요소는 Flase (0) 로 변환시킨다 pd.get_dummies (df_name [ ‘col_name’ ], prefix = “…”) prefix: dummy data 로 분리된 새 column들의 column name에 접두사 붙이기 1df['혈액형'] 0 A 1 A 2 A 3 AB 4 A 5 A 6 O 7 B 8 O 9 A 10 A 11 B 12 AB 13 O 14 O Name: 혈액형, dtype: object 1pd.get_dummies(df['혈액형']) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A AB B O 0 1 0 0 0 1 1 0 0 0 2 1 0 0 0 3 0 1 0 0 4 1 0 0 0 5 1 0 0 0 6 0 0 0 1 7 0 0 1 0 8 0 0 0 1 9 1 0 0 0 10 1 0 0 0 11 0 0 1 0 12 0 1 0 0 13 0 0 0 1 14 0 0 0 1 1pd.get_dummies(df['혈액형'], prefix = '혈액형') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 혈액형_A 혈액형_AB 혈액형_B 혈액형_O 0 1 0 0 0 1 1 0 0 0 2 1 0 0 0 3 0 1 0 0 4 1 0 0 0 5 1 0 0 0 6 0 0 0 1 7 0 0 1 0 8 0 0 0 1 9 1 0 0 0 10 1 0 0 0 11 0 0 1 0 12 0 1 0 0 13 0 0 0 1 14 0 0 0 1 categorical data의 각 카테고리가 숫자형식으로 표현됐을 때 one-hot-encoding이 더 중요해지는 이유: categorical data의 각 카테고리를 상징하는 숫자들은 그저 분류의 의미를 가질 뿐, 숫자의 크기 자체는 아무 의미도 없고, 숫자들의 연산도 역시 무의미하다. 하지만 이를 one-hot-encoding 작업 없이 머신러닝 알고리즘에 바로 넣으면 컴퓨터가 이 숫자들을 대소비교가 가능하고 연산이 가능하는 \"숫자\"로 인식하게 되므로 카테고리 간에 잘못된 관계를 맺을 수 있음. 따라서 이런 경우에는 one-hot-encoding 작업이 꼭 필요하다 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 123456blood_map = { 'A': 0, 'B': 1, 'AB': 2, 'O': 3,} 1df[\"혈액형_code\"] = df[\"혈액형\"].map(blood_map) 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 혈액형_code 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 0 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 0 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 0 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 2 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 0 1df[\"혈액형_code\"].value_counts() 0 7 3 4 2 2 1 2 Name: 혈액형_code, dtype: int64 1df[\"혈액형_code\"] 0 0 1 0 2 0 3 2 4 0 5 0 6 3 7 1 8 3 9 0 10 0 11 1 12 2 13 3 14 3 Name: 혈액형_code, dtype: int64 1pd.get_dummies(df[ \"혈액형_code\" ]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 3 0 1 0 0 0 1 1 0 0 0 2 1 0 0 0 3 0 0 1 0 4 1 0 0 0 5 1 0 0 0 6 0 0 0 1 7 0 1 0 0 8 0 0 0 1 9 1 0 0 0 10 1 0 0 0 11 0 1 0 0 12 0 0 1 0 13 0 0 0 1 14 0 0 0 1 1pd.get_dummies(df[\"혈액형_code\"], prefix = \"혈액형\") .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 혈액형_0 혈액형_1 혈액형_2 혈액형_3 0 1 0 0 0 1 1 0 0 0 2 1 0 0 0 3 0 0 1 0 4 1 0 0 0 5 1 0 0 0 6 0 0 0 1 7 0 1 0 0 8 0 0 0 1 9 1 0 0 0 10 1 0 0 0 11 0 1 0 0 12 0 0 1 0 13 0 0 0 1 14 0 0 0 1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hyemin-kim.github.io/tags/Pandas/"},{"name":"전처리","slug":"전처리","permalink":"https://hyemin-kim.github.io/tags/%EC%A0%84%EC%B2%98%EB%A6%AC/"}]},{"title":"Python >> Pandas 전처리 - (6) 데이터프레임의 산술연산","slug":"S-Python-Pandas-Pre6","date":"2020-06-20T13:28:21.000Z","updated":"2020-06-22T10:39:35.081Z","comments":true,"path":"2020/06/20/S-Python-Pandas-Pre6/","link":"","permalink":"https://hyemin-kim.github.io/2020/06/20/S-Python-Pandas-Pre6/","excerpt":"","text":"데이터프레임의 산술연산 1. Column 과 Column 간 연산 (+, -, *, /, %) 2. Column 과 숫자 간 연산 (+, -, *, /, %) 3. 복합 연산 4. mean(), sum() 을 axis 기준으로 연산 5. NaN 값이 존재할 경우 연산 6. DataFrame 과 DataFrame 간 연산 6-1. 문자열이 포함된 Series / DataFrame의 연산은 불가하다 6-2. 두 DataFrame의 column 이름은 같으나 column 순서만 바뀌어 있는 경우 6-3. 행의 갯수가 다른 경우 1import pandas as pd 1import numpy as np 예제 DataFrame 생성 1df = pd.DataFrame({\"통계\": [60, 70, 80, 85, 75], \"미술\": [50, 55, 80, 100, 95], \"체육\": [70, 65, 50, 95, 100] }) 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 통계 미술 체육 0 60 50 70 1 70 55 65 2 80 80 50 3 85 100 95 4 75 95 100 1. Column 과 Column 간 연산 (+, -, *, /, %) 1type(df[\"통계\"]) pandas.core.series.Series 즉 Series 과 Series 간의 연산 1df[\"통계\"] + df[\"미술\"] + df[\"체육\"] 0 180 1 190 2 210 3 280 4 270 dtype: int64 1df[\"통계\"] - df[\"미술\"] 0 10 1 15 2 0 3 -15 4 -20 dtype: int64 1df[\"통계\"] * df[\"미술\"] 0 3000 1 3850 2 6400 3 8500 4 7125 dtype: int64 1df[\"통계\"] / df[\"미술\"] 0 1.200000 1 1.272727 2 1.000000 3 0.850000 4 0.789474 dtype: float64 1df[\"통계\"] % df[\"미술\"] 0 10 1 15 2 0 3 85 4 75 dtype: int64 2. Column 과 숫자 간 연산 (+, -, *, /, %) 1df[\"통계\"] 0 60 1 70 2 80 3 85 4 75 Name: 통계, dtype: int64 1df[\"통계\"] + 10 0 70 1 80 2 90 3 95 4 85 Name: 통계, dtype: int64 1df[\"통계\"] - 10 0 50 1 60 2 70 3 75 4 65 Name: 통계, dtype: int64 1df[\"통계\"] * 10 0 600 1 700 2 800 3 850 4 750 Name: 통계, dtype: int64 1df[\"통계\"] / 10 0 6.0 1 7.0 2 8.0 3 8.5 4 7.5 Name: 통계, dtype: float64 1df[\"통계\"] % 10 0 0 1 0 2 0 3 5 4 5 Name: 통계, dtype: int64 3. 복합 연산 1df = pd.DataFrame({\"통계\": [60, 70, 80, 85, 75], \"미술\": [50, 55, 80, 100, 95], \"체육\": [70, 65, 50, 95, 100] }) 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 통계 미술 체육 0 60 50 70 1 70 55 65 2 80 80 50 3 85 100 95 4 75 95 100 1df[\"통계미술+10\"] = df[\"통계\"] + df[\"미술\"] + 10 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 통계 미술 체육 통계미술+10 0 60 50 70 120 1 70 55 65 135 2 80 80 50 170 3 85 100 95 195 4 75 95 100 180 1df[\"통계\"] + df[\"미술\"] - df[\"체육\"] 0 40 1 60 2 110 3 90 4 70 dtype: int64 4. mean(), sum() 을 axis 기준으로 연산 1df = pd.DataFrame({\"통계\": [60, 70, 80, 85, 75], \"미술\": [50, 55, 80, 100, 95], \"체육\": [70, 65, 50, 95, 100] }) 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 통계 미술 체육 0 60 50 70 1 70 55 65 2 80 80 50 3 85 100 95 4 75 95 100 (1) 각 column의 모든 row 값의 합 구하기 1df.sum(axis = 0) 통계 370 미술 380 체육 380 dtype: int64 (2) 각 column의 모든 row 값의 평균 구하기 1df.mean(axis = 0) 통계 74.0 미술 76.0 체육 76.0 dtype: float64 (3) 각 row의 모든 column 값의 합 구하기 1df.sum(axis = 1) 0 180 1 190 2 210 3 280 4 270 dtype: int64 (4) 각 row의 모든 column 값의 평균 구하기 1df.mean(axis = 1) 0 60.000000 1 63.333333 2 70.000000 3 93.333333 4 90.000000 dtype: float64 5. NaN 값이 존재할 경우 연산 NaN 값이 포함된 모든 연산의 결과가 다 NaN 값이다 1df = pd.DataFrame({\"통계\": [60, np.nan, 80, 85, 75], \"미술\": [50, 55, np.nan, 100, 95], \"체육\": [70, 65, 50, 95, np.nan] }) 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 통계 미술 체육 0 60.0 50.0 70.0 1 NaN 55.0 65.0 2 80.0 NaN 50.0 3 85.0 100.0 95.0 4 75.0 95.0 NaN 1df[\"통계\"] / 2 0 30.0 1 NaN 2 40.0 3 42.5 4 37.5 Name: 통계, dtype: float64 11000 / df[\"통계\"] 0 16.666667 1 NaN 2 12.500000 3 11.764706 4 13.333333 Name: 통계, dtype: float64 1df[\"통계\"] / np.nan 0 NaN 1 NaN 2 NaN 3 NaN 4 NaN Name: 통계, dtype: float64 1np.nan / df[\"통계\"] 0 NaN 1 NaN 2 NaN 3 NaN 4 NaN Name: 통계, dtype: float64 6. DataFrame 과 DataFrame 간 연산 6-1. 문자열이 포함된 Series / DataFrame의 연산은 불가하다 1df1 = pd.DataFrame({'통계': [60, 70, 80, 85, 75], '미술': [50, 55, 80, 100, 95], '체육': [70, 65, 50, 95, 100] }) 1df2 = pd.DataFrame({'통계': ['good', 'bad', 'ok' , 'good', 'ok'], '미술': [50, 60 , 80, 100, 95], '체육': [70, 65, 50, 70 , 100] }) 1df1 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 통계 미술 체육 0 60 50 70 1 70 55 65 2 80 80 50 3 85 100 95 4 75 95 100 1df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 통계 미술 체육 0 good 50 70 1 bad 60 65 2 ok 80 50 3 good 100 70 4 ok 95 100 1df1 + df2 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) D:\\Anaconda\\lib\\site-packages\\pandas\\core\\ops\\array_ops.py in na_arithmetic_op(left, right, op, str_rep) 148 try: --&gt; 149 result = expressions.evaluate(op, str_rep, left, right) 150 except TypeError: D:\\Anaconda\\lib\\site-packages\\pandas\\core\\computation\\expressions.py in evaluate(op, op_str, a, b, use_numexpr) 207 if use_numexpr: --&gt; 208 return _evaluate(op, op_str, a, b) 209 return _evaluate_standard(op, op_str, a, b) D:\\Anaconda\\lib\\site-packages\\pandas\\core\\computation\\expressions.py in _evaluate_numexpr(op, op_str, a, b) 120 if result is None: --&gt; 121 result = _evaluate_standard(op, op_str, a, b) 122 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\computation\\expressions.py in _evaluate_standard(op, op_str, a, b) 69 with np.errstate(all=\"ignore\"): ---&gt; 70 return op(a, b) 71 TypeError: unsupported operand type(s) for +: 'int' and 'str' 1df2 + 10 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) D:\\Anaconda\\lib\\site-packages\\pandas\\core\\ops\\array_ops.py in na_arithmetic_op(left, right, op, str_rep) 148 try: --&gt; 149 result = expressions.evaluate(op, str_rep, left, right) 150 except TypeError: D:\\Anaconda\\lib\\site-packages\\pandas\\core\\computation\\expressions.py in evaluate(op, op_str, a, b, use_numexpr) 207 if use_numexpr: --&gt; 208 return _evaluate(op, op_str, a, b) 209 return _evaluate_standard(op, op_str, a, b) D:\\Anaconda\\lib\\site-packages\\pandas\\core\\computation\\expressions.py in _evaluate_numexpr(op, op_str, a, b) 120 if result is None: --&gt; 121 result = _evaluate_standard(op, op_str, a, b) 122 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\computation\\expressions.py in _evaluate_standard(op, op_str, a, b) 69 with np.errstate(all=\"ignore\"): ---&gt; 70 return op(a, b) 71 TypeError: can only concatenate str (not \"int\") to str 6-2. 두 DataFrame의 column 이름은 같으나 column 순서만 바뀌어 있는 경우 연산시 자동으로 column 이름 기준으로 연산 된다 12df1 = pd.DataFrame({'미술': [10, 20, 30, 40, 50], '통계':[60, 70, 80, 90, 100] })df2 = pd.DataFrame({'통계': [10, 20, 30, 40, 50], '미술': [60, 70, 80, 90, 100] }) 1df1 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 미술 통계 0 10 60 1 20 70 2 30 80 3 40 90 4 50 100 1df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 통계 미술 0 10 60 1 20 70 2 30 80 3 40 90 4 50 100 1df1 + df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 미술 통계 0 70 70 1 90 90 2 110 110 3 130 130 4 150 150 6-3. 행의 갯수가 다른 경우 행 index 기준으로 연산하되, 하나의 DataFrame에만 존재하는 행은 연산결과가 NaN으로 나옴 12df1 = pd.DataFrame({'미술': [10, 20, 30, 40, 50, 60], '통계':[60, 70, 80, 90, 100, 110] })df2 = pd.DataFrame({'통계': [10, 20, 30, 40, 50], '미술': [60, 70, 80, 90, 100] }) 1df1 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 미술 통계 0 10 60 1 20 70 2 30 80 3 40 90 4 50 100 5 60 110 1df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 통계 미술 0 10 60 1 20 70 2 30 80 3 40 90 4 50 100 1df1 * df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 미술 통계 0 600.0 600.0 1 1400.0 1400.0 2 2400.0 2400.0 3 3600.0 3600.0 4 5000.0 5000.0 5 NaN NaN document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hyemin-kim.github.io/tags/Pandas/"},{"name":"전처리","slug":"전처리","permalink":"https://hyemin-kim.github.io/tags/%EC%A0%84%EC%B2%98%EB%A6%AC/"}]},{"title":"Python >> Pandas 전처리 - (5) column 값을 변환시키는 방법","slug":"S-Python-Pandas-Pre5","date":"2020-06-19T12:11:52.000Z","updated":"2020-06-22T10:39:29.832Z","comments":true,"path":"2020/06/19/S-Python-Pandas-Pre5/","link":"","permalink":"https://hyemin-kim.github.io/2020/06/19/S-Python-Pandas-Pre5/","excerpt":"","text":"DataFrame의 column 값을 변환시키는 방법 1. apply + 일반 함수 1-1. (목표) ‘성별’ column의 “남자” / \"여자\"를 1 / 2로 바꾼다 1-2. (목표) cm당 브랜드 평판지수를 구한다 (브랜드평판지수 / 키) 2. apply + lamda 함수 3. map + map 함수 1import pandas as pd 1df = pd.read_csv('korean-idol.csv') 1. apply + 일반 함수 apply는 Series나 DataFrame에 좀 더 구체적인 로직을 적용하고 싶은 경우 활용한다 apply를 적용하기 위해서는 함수가 먼저 정의되어야한다 apply는 정의한 로직 함수를 인자로 넘겨준다 Series에 적용할 경우: df_name [ “col_name” ] .apply( func ) DataFrame에 적용할 경우: df_name .apply( func, axis = 1) 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1-1. (목표) ‘성별’ column의 “남자” / \"여자\"를 1 / 2로 바꾼다 변환 규칙: 남자: 1 여자: 2 기타: -1 (1) 로직 함수 정의 [주의] 반드시 return 값이 존재하여야한다 12345def male_or_female(x): if x == \"남자\": return 1 elif x == \"여자\": return 2 (2) apply로 DataFrame에 적용 1df[\"성별_NEW\"] = df[\"성별\"].apply(male_or_female) 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 성별_NEW 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 1 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 1 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 1 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 2 1-2. (목표) cm당 브랜드 평판지수를 구한다 (브랜드평판지수 / 키) 변환 규칙: 키: 178 브랜드평판지수: 99000 값: 99000 / 178 (1) 로직 함수 정의 123def cm_to_brand(df): value = df[\"브랜드평판지수\"] / df[\"키\"] return value (2) apply로 DataFrame에 적용 1df.apply(cm_to_brand, axis = 1) 0 60617.857143 1 56027.949153 2 45965.250000 3 45356.747191 4 47198.815546 5 29260.308989 6 27371.321997 7 NaN 8 25503.950893 9 24156.128067 10 NaN 11 19158.617486 12 18866.594286 13 18603.051136 14 16812.885057 dtype: float64 2. apply + lamda 함수 df_name [ “col_name” ] .apply (lambda_func) lambda는 1줄로 작성하는 간단 함수식이다 return을 별도로 멱기하지 않는다 (1) male_or_female 함수 1male_or_female = lambda x: 1 if x == \"남자\" else 0 1df[\"성별\"].apply(male_or_female) 0 1 1 1 2 1 3 1 4 0 5 1 6 1 7 0 8 1 9 1 10 0 11 1 12 1 13 1 14 1 Name: 성별, dtype: int64 (2) 실제로는 간단한 계산식을 적용하려는 경우에 많이 사용한다 1df[\"키/2\"] = df[\"키\"].apply(lambda x: x / 2) 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 성별_NEW 키/2 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 86.80 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 1 88.50 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 1 90.00 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 1 89.00 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 2 81.05 apply에 함수식을 만들어서 적용해주는 것과 동일하기 때문에, 복잠한 조건식은 &lt;함수&gt;로, 간단한 계산식은 &lt; lambda &gt; 로 적용하면 된다 3. map + map 함수 df_name [ “col_name” ] .map ( map_func ) Step 1: dictionary 형식으로 map 함수를 정의하기 Step 2: DataFrame / Series에 map 함수를 적용 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 성별_NEW 키/2 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 86.80 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 1 88.50 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 1 90.00 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 1 89.00 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 2 81.05 1234my_map = { \"남자\": \"male\", \"여자\": \"female\"} 1df[\"성별\"].map(my_map) 0 male 1 male 2 male 3 male 4 female 5 male 6 male 7 female 8 male 9 male 10 female 11 male 12 male 13 male 14 male Name: 성별, dtype: object document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hyemin-kim.github.io/tags/Pandas/"},{"name":"전처리","slug":"전처리","permalink":"https://hyemin-kim.github.io/tags/%EC%A0%84%EC%B2%98%EB%A6%AC/"}]},{"title":"Python >> Pandas 전처리 - (4) Series의 Type 변환하기","slug":"S-Python-Pandas-Pre4","date":"2020-06-19T06:53:13.000Z","updated":"2020-06-22T10:39:23.643Z","comments":true,"path":"2020/06/19/S-Python-Pandas-Pre4/","link":"","permalink":"https://hyemin-kim.github.io/2020/06/19/S-Python-Pandas-Pre4/","excerpt":"","text":"Series의 Type 변환하기 1. Series의 Type 1-1. Type 확인하기 1-2. Type 변환하기 1-3. 날짜 (datatime) 타입 변환하기 1import pandas as pd 1df = pd.read_csv('korean-idol.csv') 1. Series의 Type 1-1. Type 확인하기 df_name.info() 명령어를 사용하여 Dataframe의 Series Type을 확인할 수 있다 df_name [ “col_name” ] .dtypes 명령어를 사용하여 특정 Series의 Type을 확인할 수 있다 Series Type object: 일반 문자영 타입 float: 실수 int: 정수 category: 카테고리 datatime: 시간 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 15 entries, 0 to 14 Data columns (total 8 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 이름 15 non-null object 1 그룹 14 non-null object 2 소속사 15 non-null object 3 성별 15 non-null object 4 생년월일 15 non-null object 5 키 13 non-null float64 6 혈액형 15 non-null object 7 브랜드평판지수 15 non-null int64 dtypes: float64(1), int64(1), object(6) memory usage: 1.1+ KB 1df[\"이름\"].dtypes dtype('O') 1-2. Type 변환하기 df_name [ “col_name” ] .astype(…) e.g. “키” column을 float에서 int로 변환해보기 1df[\"키\"].astype(int) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-12-c145a39acdb2&gt; in &lt;module&gt; ----&gt; 1 df[\"키\"].astype(int) D:\\Anaconda\\lib\\site-packages\\pandas\\core\\generic.py in astype(self, dtype, copy, errors) 5696 else: 5697 # else, only a single dtype is given -&gt; 5698 new_data = self._data.astype(dtype=dtype, copy=copy, errors=errors) 5699 return self._constructor(new_data).__finalize__(self) 5700 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\managers.py in astype(self, dtype, copy, errors) 580 581 def astype(self, dtype, copy: bool = False, errors: str = \"raise\"): --&gt; 582 return self.apply(\"astype\", dtype=dtype, copy=copy, errors=errors) 583 584 def convert(self, **kwargs): D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\managers.py in apply(self, f, filter, **kwargs) 440 applied = b.apply(f, **kwargs) 441 else: --&gt; 442 applied = getattr(b, f)(**kwargs) 443 result_blocks = _extend_blocks(applied, result_blocks) 444 D:\\Anaconda\\lib\\site-packages\\pandas\\core\\internals\\blocks.py in astype(self, dtype, copy, errors) 623 vals1d = values.ravel() 624 try: --&gt; 625 values = astype_nansafe(vals1d, dtype, copy=True) 626 except (ValueError, TypeError): 627 # e.g. astype_nansafe can fail on object-dtype of strings D:\\Anaconda\\lib\\site-packages\\pandas\\core\\dtypes\\cast.py in astype_nansafe(arr, dtype, copy, skipna) 866 867 if not np.isfinite(arr).all(): --&gt; 868 raise ValueError(\"Cannot convert non-finite values (NA or inf) to integer\") 869 870 elif is_object_dtype(arr): ValueError: Cannot convert non-finite values (NA or inf) to integer “키” column에 NaN값이 존재하기 때문에 Error 발생! column에 NaN 값이 있는 경우: 면저 NaN 값을 다른 값으로 대체한 후 Type을 변환할 수 있다 1df[\"키\"] = df[\"키\"].fillna(-1) 1df[\"키\"] 0 173.6 1 177.0 2 180.0 3 178.0 4 162.1 5 178.0 6 182.3 7 -1.0 8 179.2 9 167.1 10 -1.0 11 183.0 12 175.0 13 176.0 14 174.0 Name: 키, dtype: float64 1df[\"키\"].astype(int) 0 173 1 177 2 180 3 178 4 162 5 178 6 182 7 -1 8 179 9 167 10 -1 11 183 12 175 13 176 14 174 Name: 키, dtype: int32 1-3. 날짜 (datatime) 타입 변환하기 (1) datetime 타입으로 변환하기 pd.to_datetime ( df_name [ “col_nema”] ) 1df[\"생년월일\"] 0 1995-10-13 1 1988-08-18 2 1996-12-10 3 1995-12-30 4 1995-07-23 5 1997-09-01 6 1995-08-09 7 1998-08-26 8 1992-12-04 9 1994-03-22 10 1989-03-09 11 1997-03-30 12 1995-07-21 13 1995-06-08 14 1993-03-09 Name: 생년월일, dtype: object 1pd.to_datetime(df[\"생년월일\"]) 0 1995-10-13 1 1988-08-18 2 1996-12-10 3 1995-12-30 4 1995-07-23 5 1997-09-01 6 1995-08-09 7 1998-08-26 8 1992-12-04 9 1994-03-22 10 1989-03-09 11 1997-03-30 12 1995-07-21 13 1995-06-08 14 1993-03-09 Name: 생년월일, dtype: datetime64[ns] 변환된 것을 원래 column에 다시 대입을 해줘야 정상적으로 변환된 값이 들어간다 12df[\"생년월일\"] = pd.to_datetime(df[\"생년월일\"])df[\"생년월일\"] 0 1995-10-13 1 1988-08-18 2 1996-12-10 3 1995-12-30 4 1995-07-23 5 1997-09-01 6 1995-08-09 7 1998-08-26 8 1992-12-04 9 1994-03-22 10 1989-03-09 11 1997-03-30 12 1995-07-21 13 1995-06-08 14 1993-03-09 Name: 생년월일, dtype: datetime64[ns] (2) datatime 타입을 활용하기 df_name [ “datetime_col” ] .dt 을 활용하여 매우 손쉽게 년, 월, 일, 요일 등등 날짜 정보를 세부적으로 추출해낼 수 있다 년: df_name [ “datetime_col” ] .dt.year 월: df_name [ “datetime_col” ] .dt.month 일: df_name [ “datetime_col” ] .dt.day 요일: df_name [ “datetime_col” ] .dt.dayofweek 주: df_name [ “datetime_col” ] .dt.weekofyear 1df[\"생년월일\"] 0 1995-10-13 1 1988-08-18 2 1996-12-10 3 1995-12-30 4 1995-07-23 5 1997-09-01 6 1995-08-09 7 1998-08-26 8 1992-12-04 9 1994-03-22 10 1989-03-09 11 1997-03-30 12 1995-07-21 13 1995-06-08 14 1993-03-09 Name: 생년월일, dtype: datetime64[ns] 년 추출: 1df[\"생년월일\"].dt.year 0 1995 1 1988 2 1996 3 1995 4 1995 5 1997 6 1995 7 1998 8 1992 9 1994 10 1989 11 1997 12 1995 13 1995 14 1993 Name: 생년월일, dtype: int64 월 추출: 1df[\"생년월일\"].dt.month 0 10 1 8 2 12 3 12 4 7 5 9 6 8 7 8 8 12 9 3 10 3 11 3 12 7 13 6 14 3 Name: 생년월일, dtype: int64 일 추출: 1df[\"생년월일\"].dt.day 0 13 1 18 2 10 3 30 4 23 5 1 6 9 7 26 8 4 9 22 10 9 11 30 12 21 13 8 14 9 Name: 생년월일, dtype: int64 요일 추출: 월 [0], 화 [1], 수 [2], 목 [3], 금 [4], 토 [5], 일 [6] 1df[\"생년월일\"].dt.dayofweek 0 4 1 3 2 1 3 5 4 6 5 0 6 2 7 2 8 4 9 1 10 3 11 6 12 4 13 3 14 1 Name: 생년월일, dtype: int64 주 추출: 1df[\"생년월일\"].dt.weekofyear 0 41 1 33 2 50 3 52 4 29 5 36 6 32 7 35 8 49 9 12 10 10 11 13 12 29 13 23 14 10 Name: 생년월일, dtype: int64 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hyemin-kim.github.io/tags/Pandas/"},{"name":"전처리","slug":"전처리","permalink":"https://hyemin-kim.github.io/tags/%EC%A0%84%EC%B2%98%EB%A6%AC/"}]},{"title":"Python >> Pandas 전처리 - (3) DataFrame의 합침 및 병합","slug":"S-Python-Pandas-Pre3","date":"2020-06-19T06:52:54.000Z","updated":"2020-06-22T10:39:17.661Z","comments":true,"path":"2020/06/19/S-Python-Pandas-Pre3/","link":"","permalink":"https://hyemin-kim.github.io/2020/06/19/S-Python-Pandas-Pre3/","excerpt":"","text":"DataFrame의 합침 및 병합 1. DataFrame 합치기 (concat) 1-1. Row 기준 합치기 (밑으로 합침) 1-2. column 기준으로 합치기 (옆으로 합침) 2. DataFrame 병합하기 (merge) 2-0. 예제 데이터 만들기 2-1. left, right 방식 2-2. inner, outer 방식 2-3. column명은 다르지만, 동일한 성질의 데이터 인 경우? 1import pandas as pd 1df = pd.read_csv('korean-idol.csv') 1df2 = pd.read_csv('korean-idol-2.csv') 1. DataFrame 합치기 (concat) 1-1. Row 기준 합치기 (밑으로 합침) df_concat = pd.concat ( [ df_name1 , df_name2 ], sort = False) df_concat .reset_index (drop = True) 합칠 데이터프리임을 list로 묶어준다. sort=False 옵션을 주어 column의 순서가 유지되도록 한다 합친 dataframe을 새 변수에 대입한 뒤 reset_index 옵션으로 index를 초기화한다 (아님 각각 원래의 index을 가지고 있음) reseet_index에서 drop=True 옵션을 사용해 원래의 행 index가 새로 index column으로 생성되지 않도록 한다 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1df_copy = df.copy() (1) sort 옵션 sort = False: column 순서 유지; sort = True: column을 이름순으로 재정열 1pd.concat([df, df_copy], sort = False) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 1pd.concat([df, df_copy], sort = True) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 그룹 브랜드평판지수 생년월일 성별 소속사 이름 키 혈액형 0 방탄소년단 10523260 1995-10-13 남자 빅히트 지민 173.6 A 1 빅뱅 9916947 1988-08-18 남자 YG 지드래곤 177.0 A 2 NaN 8273745 1996-12-10 남자 커넥트 강다니엘 180.0 A 3 방탄소년단 8073501 1995-12-30 남자 빅히트 뷔 178.0 AB 4 마마무 7650928 1995-07-23 여자 RBW 화사 162.1 A 5 방탄소년단 5208335 1997-09-01 남자 빅히트 정국 178.0 A 6 뉴이스트 4989792 1995-08-09 남자 플레디스 민현 182.3 O 7 아이들 4668615 1998-08-26 여자 큐브 소연 NaN B 8 방탄소년단 4570308 1992-12-04 남자 빅히트 진 179.2 O 9 핫샷 4036489 1994-03-22 남자 스타크루이엔티 하성운 167.1 A 10 소녀시대 3918661 1989-03-09 여자 SM 태연 NaN A 11 아스트로 3506027 1997-03-30 남자 판타지오 차은우 183.0 B 12 뉴이스트 3301654 1995-07-21 남자 플레디스 백호 175.0 AB 13 뉴이스트 3274137 1995-06-08 남자 플레디스 JR 176.0 O 14 방탄소년단 2925442 1993-03-09 남자 빅히트 슈가 174.0 O 0 방탄소년단 10523260 1995-10-13 남자 빅히트 지민 173.6 A 1 빅뱅 9916947 1988-08-18 남자 YG 지드래곤 177.0 A 2 NaN 8273745 1996-12-10 남자 커넥트 강다니엘 180.0 A 3 방탄소년단 8073501 1995-12-30 남자 빅히트 뷔 178.0 AB 4 마마무 7650928 1995-07-23 여자 RBW 화사 162.1 A 5 방탄소년단 5208335 1997-09-01 남자 빅히트 정국 178.0 A 6 뉴이스트 4989792 1995-08-09 남자 플레디스 민현 182.3 O 7 아이들 4668615 1998-08-26 여자 큐브 소연 NaN B 8 방탄소년단 4570308 1992-12-04 남자 빅히트 진 179.2 O 9 핫샷 4036489 1994-03-22 남자 스타크루이엔티 하성운 167.1 A 10 소녀시대 3918661 1989-03-09 여자 SM 태연 NaN A 11 아스트로 3506027 1997-03-30 남자 판타지오 차은우 183.0 B 12 뉴이스트 3301654 1995-07-21 남자 플레디스 백호 175.0 AB 13 뉴이스트 3274137 1995-06-08 남자 플레디스 JR 176.0 O 14 방탄소년단 2925442 1993-03-09 남자 빅히트 슈가 174.0 O (2) reset_index 옵션 reset_index(): index가 초기화됨, 원래의 index가 새로 index column으로 저장됨 reset_index(drop = True): index가 초기화됨, 원래의 index가 새로 index column으로 생성되지 않음 1df_concat = pd.concat([df, df_copy], sort = False) 1df_concat.reset_index() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } index 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 15 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 16 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 17 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 18 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 19 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 20 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 21 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 22 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 23 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 24 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 25 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 26 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 27 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 28 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 29 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 1df_concat.reset_index(drop = True) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 15 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 16 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 17 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 18 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 19 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 20 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 21 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 22 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 23 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 24 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 25 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 26 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 27 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 28 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 29 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 1-2. column 기준으로 합치기 (옆으로 합침) column 기준으로 합치고자 할 때는 axis = 1 옵션을 준다: pd.concat ( [df_name1, df_name2], axis = 1) 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1df2 = pd.read_csv('korean-idol-2.csv') 1df2.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 연봉 가족수 0 지민 3000 3 1 지드래곤 3500 3 2 강다니엘 3200 4 3 뷔 3050 4 4 화사 4300 3 1pd.concat([df, df2], axis = 1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 이름 연봉 가족수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 지민 3000 3 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 지드래곤 3500 3 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 강다니엘 3200 4 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 뷔 3050 4 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 화사 4300 3 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 정국 2900 5 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 민현 3400 6 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 소연 4500 5 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 진 4200 4 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 하성운 4300 4 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 태연 3700 3 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 차은우 3850 5 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 백호 3900 4 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 JR 4100 3 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 슈가 4150 3 행의 갯수가 맞지 않을 시 두 DataFrame이 행 index기준으로 합치게 됨 행 갯수가 적은 DataFrame의 빈칸에는 NaN로 채워지게 됨 12df3 = df2.drop([3,5])df3 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 연봉 가족수 0 지민 3000 3 1 지드래곤 3500 3 2 강다니엘 3200 4 4 화사 4300 3 6 민현 3400 6 7 소연 4500 5 8 진 4200 4 9 하성운 4300 4 10 태연 3700 3 11 차은우 3850 5 12 백호 3900 4 13 JR 4100 3 14 슈가 4150 3 1pd.concat([df, df3], axis = 1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 이름 연봉 가족수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 지민 3000.0 3.0 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 지드래곤 3500.0 3.0 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 강다니엘 3200.0 4.0 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 NaN NaN NaN 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 화사 4300.0 3.0 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 NaN NaN NaN 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 민현 3400.0 6.0 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 소연 4500.0 5.0 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 진 4200.0 4.0 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 하성운 4300.0 4.0 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 태연 3700.0 3.0 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 차은우 3850.0 5.0 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 백호 3900.0 4.0 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 JR 4100.0 3.0 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 슈가 4150.0 3.0 12df4 = df2.drop([13, 14])pd.concat([df,df4], axis = 1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 이름 연봉 가족수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 지민 3000.0 3.0 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 지드래곤 3500.0 3.0 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 강다니엘 3200.0 4.0 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 뷔 3050.0 4.0 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 화사 4300.0 3.0 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 정국 2900.0 5.0 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 민현 3400.0 6.0 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 소연 4500.0 5.0 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 진 4200.0 4.0 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 하성운 4300.0 4.0 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 태연 3700.0 3.0 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 차은우 3850.0 5.0 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 백호 3900.0 4.0 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 NaN NaN NaN 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 NaN NaN NaN 2. DataFrame 병합하기 (merge) concat과 merge의 차이: concat: row 나 column 기준으로 단순하게 이어 붙히기 merge: 특정 고유한 키(unique id) 값을 기준으로 병합하기 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1df2.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 연봉 가족수 0 지민 3000 3 1 지드래곤 3500 3 2 강다니엘 3200 4 3 뷔 3050 4 4 화사 4300 3 df와 df2는 \"이름\"이라는 column이 겹친다 따라서, 우리는 \"이름\"을 기준으로 두 DataFrame을 병합할 수 있다 pd.merge (left_df, right_df, on = “기준 column”, how = “…” ) left_df와 right_df 에는 병합할 두 DataFrame을 대입한다 on 에는 병합의 기준이 되는 column을 넣어 준다 how 에는 ‘left’, ‘right’, ‘inner’, 'outer’라는 4가지의 병합 방식중 한가지를 택한다 2-0. 예제 데이터 만들기 1df_right = df2.drop([1,3,5,7]) 1df_right .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 연봉 가족수 0 지민 3000 3 2 강다니엘 3200 4 4 화사 4300 3 6 민현 3400 6 8 진 4200 4 9 하성운 4300 4 10 태연 3700 3 11 차은우 3850 5 12 백호 3900 4 13 JR 4100 3 14 슈가 4150 3 12df_right = df_right.reset_index(drop = True)df_right .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 연봉 가족수 0 지민 3000 3 1 강다니엘 3200 4 2 화사 4300 3 3 민현 3400 6 4 진 4200 4 5 하성운 4300 4 6 태연 3700 3 7 차은우 3850 5 8 백호 3900 4 9 JR 4100 3 10 슈가 4150 3 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 concat로 합치는 경우: 데이터가 행 index기준으로 합치게 되기 때문에 이름이 다른 시람의 데이터가 합치게 된다 1pd.concat([df, df_right], axis = 1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 이름 연봉 가족수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 지민 3000.0 3.0 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 강다니엘 3200.0 4.0 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 화사 4300.0 3.0 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 민현 3400.0 6.0 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 진 4200.0 4.0 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 하성운 4300.0 4.0 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 태연 3700.0 3.0 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 차은우 3850.0 5.0 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 백호 3900.0 4.0 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 JR 4100.0 3.0 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 슈가 4150.0 3.0 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 NaN NaN NaN 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 NaN NaN NaN 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 NaN NaN NaN 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 NaN NaN NaN 따리서, 우리는 merge를 사용하여 두 DataFrame를 “이름” 기준으로 병합한다 2-1. left, right 방식 \"left\"옵션을 부여할 때: left DataFrame에 키 값이 존재하면 해당 데이터를 유지하고, 병합한 right DataFrame의 값은 NaN이 대입 됨 반대로, \"right\"옵션을 부여할 때 right DataFrame을 기준으로 병합하게 됨 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 1df_right .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 연봉 가족수 0 지민 3000 3 1 강다니엘 3200 4 2 화사 4300 3 3 민현 3400 6 4 진 4200 4 5 하성운 4300 4 6 태연 3700 3 7 차은우 3850 5 8 백호 3900 4 9 JR 4100 3 10 슈가 4150 3 1pd.merge(df, df_right, on = \"이름\", how = \"left\") .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 연봉 가족수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 3000.0 3.0 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 NaN NaN 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3200.0 4.0 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 NaN NaN 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 4300.0 3.0 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 NaN NaN 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 3400.0 6.0 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 NaN NaN 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 4200.0 4.0 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 4300.0 4.0 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 3700.0 3.0 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 3850.0 5.0 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 3900.0 4.0 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 4100.0 3.0 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 4150.0 3.0 1pd.merge(df, df_right, on = \"이름\", how = \"right\") .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 연봉 가족수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 3000 3 1 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3200 4 2 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 4300 3 3 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 3400 6 4 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 4200 4 5 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 4300 4 6 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 3700 3 7 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 3850 5 8 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 3900 4 9 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 4100 3 10 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 4150 3 현재, left DataFrame이 더 많은 데이터를 보유하고 있으니, right를 기준으로 병합하면 DataFrame 사이즈가 줄어드게 된다 2-2. inner, outer 방식 inner 방식은 두 DataFrame에 모두 키 값이 존재하는 경우만 병합한다 (교집합과 비슷) outer 방식은 하나의 DataFrame에만 키 값이 존재하더라도 모두 병합한다 (합집합과 비슷) outer 방식에서는 없는 값은 NaN으로 대입된다 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 1df_right .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 연봉 가족수 0 지민 3000 3 1 강다니엘 3200 4 2 화사 4300 3 3 민현 3400 6 4 진 4200 4 5 하성운 4300 4 6 태연 3700 3 7 차은우 3850 5 8 백호 3900 4 9 JR 4100 3 10 슈가 4150 3 1pd.merge(df, df_right, on = \"이름\", how = 'inner') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 연봉 가족수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 3000 3 1 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3200 4 2 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 4300 3 3 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 3400 6 4 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 4200 4 5 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 4300 4 6 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 3700 3 7 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 3850 5 8 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 3900 4 9 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 4100 3 10 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 4150 3 1pd.merge(df, df_right, on = \"이름\", how = 'outer') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 연봉 가족수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 3000.0 3.0 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 NaN NaN 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3200.0 4.0 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 NaN NaN 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 4300.0 3.0 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 NaN NaN 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 3400.0 6.0 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 NaN NaN 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 4200.0 4.0 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 4300.0 4.0 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 3700.0 3.0 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 3850.0 5.0 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 3900.0 4.0 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 4100.0 3.0 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 4150.0 3.0 2-3. column명은 다르지만, 동일한 성질의 데이터 인 경우? pd.merge ( left_df, right_df, left_on = “left_col”, right_on = “right_col”, how = “…” ) 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1df_right.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 연봉 가족수 0 지민 3000 3 1 강다니엘 3200 4 2 화사 4300 3 3 민현 3400 6 4 진 4200 4 1df_right.columns = [\"성함\", \"연봉\", \"기족수\"] 1df_right.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 성함 연봉 기족수 0 지민 3000 3 1 강다니엘 3200 4 2 화사 4300 3 3 민현 3400 6 4 진 4200 4 df의 \"이름\"과 df_right의 \"성함\"은 column name이 다르지만, 동일한 성질의 데이터다. 이럴 때는 left_on, right_on 옵션을 사용해 기준 column을 지정한다 1pd.merge(df, df_right, left_on = \"이름\", right_on = \"성함\", how = \"outer\") .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 성함 연봉 기족수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 지민 3000.0 3.0 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 NaN NaN NaN 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 강다니엘 3200.0 4.0 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 NaN NaN NaN 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 화사 4300.0 3.0 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 NaN NaN NaN 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 민현 3400.0 6.0 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 NaN NaN NaN 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 진 4200.0 4.0 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 하성운 4300.0 4.0 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 태연 3700.0 3.0 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 차은우 3850.0 5.0 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 백호 3900.0 4.0 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 JR 4100.0 3.0 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 슈가 4150.0 3.0 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hyemin-kim.github.io/tags/Pandas/"},{"name":"전처리","slug":"전처리","permalink":"https://hyemin-kim.github.io/tags/%EC%A0%84%EC%B2%98%EB%A6%AC/"}]},{"title":"Python >> Pandas 전처리 - (2) 결측값 및 중복값 처리","slug":"S-Python-Pandas-Pre2","date":"2020-06-17T15:07:04.000Z","updated":"2020-06-22T10:39:10.921Z","comments":true,"path":"2020/06/18/S-Python-Pandas-Pre2/","link":"","permalink":"https://hyemin-kim.github.io/2020/06/18/S-Python-Pandas-Pre2/","excerpt":"","text":"결측값 및 중복값 처리 1. 결측값을 제거하기 – dropna() 2. 결측값을 채워주기 – fillna 2-1. NA값을 특정 숫자로 채우기 2-2. NA값을 통계값으로 채우기 3. 중복된 값을 제거하기 – drop_duplicates 3-1. column의 중복값 제거 3-2. 행 전체 제거 1import pandas as pd 1df = pd.read_csv('korean-idol.csv') 1. 결측값을 제거하기 – dropna() 결측값이 있는 행을 제거: (1) df_name .dropna() (2) df_name .dropna(axis=0) 결측값이 있는 열을 제거: df_name .dropna(axis=1) NA가 하나라도 있는 경우 제거: df_name .dropna(axis=0, how = ‘any’) 모두가 NA인 경우 제거: df_name .dropna(axis=0, how = ‘all’) 1df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 15 entries, 0 to 14 Data columns (total 8 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 이름 15 non-null object 1 그룹 14 non-null object 2 소속사 15 non-null object 3 성별 15 non-null object 4 생년월일 15 non-null object 5 키 13 non-null float64 6 혈액형 15 non-null object 7 브랜드평판지수 15 non-null int64 dtypes: float64(1), int64(1), object(6) memory usage: 1.1+ KB 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 (1) 결측값이 있는 행 제거 1df.dropna() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 1df.dropna(axis = 0) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 (2) 결측 값이 있는 열 제거 1df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 15 entries, 0 to 14 Data columns (total 8 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 이름 15 non-null object 1 그룹 14 non-null object 2 소속사 15 non-null object 3 성별 15 non-null object 4 생년월일 15 non-null object 5 키 13 non-null float64 6 혈액형 15 non-null object 7 브랜드평판지수 15 non-null int64 dtypes: float64(1), int64(1), object(6) memory usage: 1.1+ KB 1df.dropna(axis=1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 소속사 성별 생년월일 혈액형 브랜드평판지수 0 지민 빅히트 남자 1995-10-13 A 10523260 1 지드래곤 YG 남자 1988-08-18 A 9916947 2 강다니엘 커넥트 남자 1996-12-10 A 8273745 3 뷔 빅히트 남자 1995-12-30 AB 8073501 4 화사 RBW 여자 1995-07-23 A 7650928 5 정국 빅히트 남자 1997-09-01 A 5208335 6 민현 플레디스 남자 1995-08-09 O 4989792 7 소연 큐브 여자 1998-08-26 B 4668615 8 진 빅히트 남자 1992-12-04 O 4570308 9 하성운 스타크루이엔티 남자 1994-03-22 A 4036489 10 태연 SM 여자 1989-03-09 A 3918661 11 차은우 판타지오 남자 1997-03-30 B 3506027 12 백호 플레디스 남자 1995-07-21 AB 3301654 13 JR 플레디스 남자 1995-06-08 O 3274137 14 슈가 빅히트 남자 1993-03-09 O 2925442 (3) NA가 하나라도 있는 경우 행 제거 1df.dropna(axis=0, how = 'any') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 (4) 모두가 NA인 경우 행 제거 1import numpy as np 1df.iloc[10] = np.nan 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260.0 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947.0 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745.0 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501.0 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928.0 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335.0 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792.0 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615.0 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308.0 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489.0 10 NaN NaN NaN NaN NaN NaN NaN NaN 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027.0 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654.0 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137.0 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442.0 1df.dropna(axis=0, how = 'all') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260.0 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947.0 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745.0 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501.0 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928.0 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335.0 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792.0 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615.0 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308.0 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489.0 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027.0 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654.0 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137.0 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442.0 2. 결측값을 채워주기 – fillna df_name [ 'na_col_name ’ ] .fillna(fill_value) 결측값을 채운 데이터프레임을 유지시키려면: (1) inplace = True 옵션을 추가함 (2) 원 dataframe에 다시 대입함 1df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 15 entries, 0 to 14 Data columns (total 8 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 이름 15 non-null object 1 그룹 14 non-null object 2 소속사 15 non-null object 3 성별 15 non-null object 4 생년월일 15 non-null object 5 키 13 non-null float64 6 혈액형 15 non-null object 7 브랜드평판지수 15 non-null int64 dtypes: float64(1), int64(1), object(6) memory usage: 1.1+ KB \"키\"에 2개의 데이터가 누락, \"그룹\"에 1개의 데이터가 누락된 것을 확인할 수 있다 2-1. NA값을 특정 숫자로 채우기 df_name[ 'na_col_name ’ ] .fillna (new_value, inplace = True) df_name[ 'na_col_name ’ ] = df_name[ 'na_col_name ’ ] .fillna (new_value) e.g. 누락된 ‘키’ 값을 '-1’로 채워줌 1df['키'].fillna(-1) 0 173.6 1 177.0 2 180.0 3 178.0 4 162.1 5 178.0 6 182.3 7 -1.0 8 179.2 9 167.1 10 -1.0 11 183.0 12 175.0 13 176.0 14 174.0 Name: 키, dtype: float64 이때는 원 데이터가 변화되지 않음. 1df['키'] 0 173.6 1 177.0 2 180.0 3 178.0 4 162.1 5 178.0 6 182.3 7 NaN 8 179.2 9 167.1 10 NaN 11 183.0 12 175.0 13 176.0 14 174.0 Name: 키, dtype: float64 수정된 데이터를 유지시키려면: &lt;방법1&gt; 1df2 = df.copy() 1df2['키'].fillna(-1, inplace = True) 1df2['키'] 0 173.6 1 177.0 2 180.0 3 178.0 4 162.1 5 178.0 6 182.3 7 -1.0 8 179.2 9 167.1 10 -1.0 11 183.0 12 175.0 13 176.0 14 174.0 Name: 키, dtype: float64 &lt;방법2&gt; 1df2 = df.copy() 1df2['키'] = df2['키'].fillna(-1) 1df2['키'] 0 173.6 1 177.0 2 180.0 3 178.0 4 162.1 5 178.0 6 182.3 7 -1.0 8 179.2 9 167.1 10 -1.0 11 183.0 12 175.0 13 176.0 14 174.0 Name: 키, dtype: float64 2-2. NA값을 통계값으로 채우기 df_name[ 'na_col_name ’ ] .fillna (df_name[ 'na_col_name ’ ] .mean(), inplace = True) df_name[ 'na_col_name ’ ] = df_name[ 'na_col_name ’ ] .fillna (df_name[ 'na_col_name ’ ] .mean()) 1df2 = df.copy() 1df2['키'] 0 173.6 1 177.0 2 180.0 3 178.0 4 162.1 5 178.0 6 182.3 7 NaN 8 179.2 9 167.1 10 NaN 11 183.0 12 175.0 13 176.0 14 174.0 Name: 키, dtype: float64 (1) 평균으로 대체 1df2['키'].mean() 175.79230769230767 1df2['키'].fillna(df2['키'].mean(), inplace = True) 1df2['키'] = df2['키'].fillna(df2['키'].mean()) 1df2['키'] 0 173.600000 1 177.000000 2 180.000000 3 178.000000 4 162.100000 5 178.000000 6 182.300000 7 175.792308 8 179.200000 9 167.100000 10 175.792308 11 183.000000 12 175.000000 13 176.000000 14 174.000000 Name: 키, dtype: float64 (2) 중위값으로 대체 1df2 = df.copy() 1df2['키'].median() 177.0 1df2['키'].fillna(df2['키'].median(), inplace = True) 1df2['키'] = df2['키'].fillna(df2['키'].median()) 1df2['키'] 0 173.6 1 177.0 2 180.0 3 178.0 4 162.1 5 178.0 6 182.3 7 177.0 8 179.2 9 167.1 10 177.0 11 183.0 12 175.0 13 176.0 14 174.0 Name: 키, dtype: float64 3. 중복된 값을 제거하기 – drop_duplicates 1df = pd.read_csv('korean-idol.csv') 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 3-1. column의 중복값 제거 df_name [“col_name”] .drop_duplicates( keep = … ) 여러 개 중복값 (NaN 포함) 중에서 기본적으로 첫번째 것만 유지시키고 나머지는 다 제거한다 하지만 keep 옵션으로 유지하고 싶은 데이터를 선택할 수 있다. [keep: ‘first’ / ‘last’] 이때는 해당 위치의 값만 삭제되고 행 자체는 유지된다 (1) 중복값 중의 첫번째를 유지시킴 (default) 1df['키'] 0 173.6 1 177.0 2 180.0 3 NaN 4 162.1 5 178.0 6 182.3 7 NaN 8 179.2 9 167.1 10 NaN 11 183.0 12 175.0 13 176.0 14 174.0 Name: 키, dtype: float64 1df['키'].drop_duplicates() # remove 2nd \"178.0\" &amp; 2nd \"NaN\" 0 173.6 1 177.0 2 180.0 3 NaN 4 162.1 5 178.0 6 182.3 8 179.2 9 167.1 11 183.0 12 175.0 13 176.0 14 174.0 Name: 키, dtype: float64 1df['키'].drop_duplicates(keep='first') 0 173.6 1 177.0 2 180.0 3 NaN 4 162.1 5 178.0 6 182.3 8 179.2 9 167.1 11 183.0 12 175.0 13 176.0 14 174.0 Name: 키, dtype: float64 (2) 중복값 중의 마지막을 유지시킴 1df['키'] 0 173.6 1 177.0 2 180.0 3 178.0 4 162.1 5 178.0 6 182.3 7 NaN 8 179.2 9 167.1 10 NaN 11 183.0 12 175.0 13 176.0 14 174.0 Name: 키, dtype: float64 1df['키'].drop_duplicates(keep='last') 0 173.6 1 177.0 2 180.0 4 162.1 5 178.0 6 182.3 8 179.2 9 167.1 10 NaN 11 183.0 12 175.0 13 176.0 14 174.0 Name: 키, dtype: float64 이때는 해당위치의 값만 제거되고 행 자체는 유지됨 1df['키'] = df['키'].drop_duplicates(keep='last') 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 NaN AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 3-2. 행 전체 제거 df_name .drop_duplicates(“col_name”, keep = …) 지정한 column에서 중복값이 포함되어 있으면 중복값을 포함한 행을 전체 제거 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 NaN AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 1df['그룹'] 0 방탄소년단 1 빅뱅 2 NaN 3 방탄소년단 4 마마무 5 방탄소년단 6 뉴이스트 7 아이들 8 방탄소년단 9 핫샷 10 소녀시대 11 아스트로 12 뉴이스트 13 뉴이스트 14 방탄소년단 Name: 그룹, dtype: object 1df.drop_duplicates('그룹') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 1df.drop_duplicates('그룹', keep = 'last') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hyemin-kim.github.io/tags/Pandas/"},{"name":"전처리","slug":"전처리","permalink":"https://hyemin-kim.github.io/tags/%EC%A0%84%EC%B2%98%EB%A6%AC/"}]},{"title":"Python >> Pandas 전처리 - (1) row & column 의 추가 및 제거","slug":"S-Python-Pandas-Pre1","date":"2020-06-17T15:02:25.000Z","updated":"2020-06-22T10:39:00.230Z","comments":true,"path":"2020/06/18/S-Python-Pandas-Pre1/","link":"","permalink":"https://hyemin-kim.github.io/2020/06/18/S-Python-Pandas-Pre1/","excerpt":"","text":"row &amp; column 의 추가 및 제거 1. row의 추가 2. column의 추가 3. row의 제거 4. column의 제거 1import pandas as pd 1df = pd.read_csv('korean-idol.csv') 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1. row의 추가 df_name .append ( {…} , ignore_index = True ) dictionary 형태의 데이터를 만들어 준다음 append() 함수를 사용하여 데이터를 추가할 수 있다. ignore_index=True옵션을 반드시 같이 추가해야한다 1df = df.append({'이름': '홍길동', '그룹': 'a그룹', '소속사':'A사', '성별': '남자', '생년월일': '1990-01-01', '키': 185.0, '혈액형': 'B', '브랜드평판지수': 12345678}, ignore_index=True) 1df.tail() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 15 홍길동 a그룹 A사 남자 1990-01-01 185.0 B 12345678 2. column의 추가 새로운 column을 만들고 값을 대입해주면, column이 쉽게 추가될 수 있다 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1df['국적'] = '대한민국' 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 국적 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 대한민국 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 대한민국 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 대한민국 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 대한민국 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 대한민국 새로운 column의 값을 다르게 부여하고 싶다면 loc 함수를 활용하면 된다 1df.loc[ df['이름'] == '지드래곤', '국적'] = 'korea' 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 국적 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 대한민국 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 korea 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 대한민국 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 대한민국 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 대한민국 3. row의 제거 하나의 행: df_name .drop (index_num, axis = 0) 복수의 행: df_name .drop ( [ index_num1, index_num2 ], axis = 0) 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 1df.drop(3, axis = 0) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 1df.drop([3, 5], axis = 0) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 4. column의 제거 하나의 열: df_name .drop ( ‘col_name’, axis = 1) 복수의 열: df_name .drop ( [ ‘col_name1’, ‘col_name2’ ], axis = 1) 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 1df.drop(\"그룹\", axis = 1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 큐브 여자 1998-08-26 NaN B 4668615 8 진 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 SM 여자 1989-03-09 NaN A 3918661 11 차은우 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 빅히트 남자 1993-03-09 174.0 O 2925442 1df.drop([\"그룹\", \"소속사\"], axis = 1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 남자 1995-10-13 173.6 A 10523260 1 지드래곤 남자 1988-08-18 177.0 A 9916947 2 강다니엘 남자 1996-12-10 180.0 A 8273745 3 뷔 남자 1995-12-30 178.0 AB 8073501 4 화사 여자 1995-07-23 162.1 A 7650928 5 정국 남자 1997-09-01 178.0 A 5208335 6 민현 남자 1995-08-09 182.3 O 4989792 7 소연 여자 1998-08-26 NaN B 4668615 8 진 남자 1992-12-04 179.2 O 4570308 9 하성운 남자 1994-03-22 167.1 A 4036489 10 태연 여자 1989-03-09 NaN A 3918661 11 차은우 남자 1997-03-30 183.0 B 3506027 12 백호 남자 1995-07-21 175.0 AB 3301654 13 JR 남자 1995-06-08 176.0 O 3274137 14 슈가 남자 1993-03-09 174.0 O 2925442 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hyemin-kim.github.io/tags/Pandas/"},{"name":"전처리","slug":"전처리","permalink":"https://hyemin-kim.github.io/tags/%EC%A0%84%EC%B2%98%EB%A6%AC/"}]},{"title":"Python >> Pandas 데이터 파악 - (7) 기타","slug":"S-Python-Pandas7","date":"2020-06-17T06:12:40.000Z","updated":"2020-06-22T10:40:59.480Z","comments":true,"path":"2020/06/17/S-Python-Pandas7/","link":"","permalink":"https://hyemin-kim.github.io/2020/06/17/S-Python-Pandas7/","excerpt":"","text":"기타 1. 피벗테이블 2. GroupBy (그룹으로 묶어 보기) 3. Multi-Index (복합 인덱스) 3-1. Multi-Index 적용 3-2. Multi-Index 데이터 프레임을 피벗테이블로 변환 3-3. 인덱스 초기화 (reset_index) 1import pandas as pd 1df = pd.read_csv('korean-idol.csv') 1. 피벗테이블 데이터 열 중에서 두 개의 열을 각각 행 인덱스, 열 인덱스로 사용하여 데이터를 조회하여 펼쳐놓은 건을 의미함 왼쪽에 나타나는 인덱스를 행 인덱스, 상단에 나타나는 인덱스를 열 인덱스라고 부른다 pd.pivot_table(df_name, index = “col_name_분류기준1”, columns = “col_name_분류기준2”, values = “col_name_조회대상”, aggfunc = …) index는 행 인덱스 columns는 열 인덱스 values는 조회하고 싶은 값 aggfunc는 value를 산출하는 연산법 (1) e.g.: aggfunc = np.sum / np.mean (2) 설정하지 않은 경우 기본적으로 평균값을 구한다 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1pd.pivot_table(df, index = \"소속사\", columns = \"혈액형\", values = \"키\") .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 혈액형 A AB B O 소속사 RBW 162.1 NaN NaN NaN YG 177.0 NaN NaN NaN 빅히트 175.8 178.0 NaN 176.60 스타크루이엔티 167.1 NaN NaN NaN 커넥트 180.0 NaN NaN NaN 판타지오 NaN NaN 183.0 NaN 플레디스 NaN 175.0 NaN 179.15 1import numpy as np 1pd.pivot_table(df, index = \"그룹\", columns = \"혈액형\", values = \"브랜드평판지수\", aggfunc = np.sum) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 혈액형 A AB B O 그룹 뉴이스트 NaN 3301654.0 NaN 8263929.0 마마무 7650928.0 NaN NaN NaN 방탄소년단 15731595.0 8073501.0 NaN 7495750.0 빅뱅 9916947.0 NaN NaN NaN 소녀시대 3918661.0 NaN NaN NaN 아스트로 NaN NaN 3506027.0 NaN 아이들 NaN NaN 4668615.0 NaN 핫샷 4036489.0 NaN NaN NaN 2. GroupBy (그룹으로 묶어 보기) groupby는 데이터를 그룹으로 묶어 분석할 때 활용한다 소속사별 키의 평균, 성별 키의 평균 등 특정, 그룹별 통계 및 데이터의 성질을 확인하고자 할 때 활용한다 groupby와 함께 count() - 갯수 sum() - 합계 mean() - 평균 var() - 분산 std() -표준편차 min() / max() - 최소값, 최대값 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1df.groupby(\"소속사\") &lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x0000024E760EC288&gt; 1df.groupby('소속사').count() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 성별 생년월일 키 혈액형 브랜드평판지수 소속사 RBW 1 1 1 1 1 1 1 SM 1 1 1 1 0 1 1 YG 1 1 1 1 1 1 1 빅히트 5 5 5 5 5 5 5 스타크루이엔티 1 1 1 1 1 1 1 커넥트 1 0 1 1 1 1 1 큐브 1 1 1 1 0 1 1 판타지오 1 1 1 1 1 1 1 플레디스 3 3 3 3 3 3 3 산술 통계는 자동으로 산술통계가 가능한 열만 출력됨. 1df.groupby('그룹').mean() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 키 브랜드평판지수 그룹 뉴이스트 177.766667 3.855194e+06 마마무 162.100000 7.650928e+06 방탄소년단 176.560000 6.260169e+06 빅뱅 177.000000 9.916947e+06 소녀시대 NaN 3.918661e+06 아스트로 183.000000 3.506027e+06 아이들 NaN 4.668615e+06 핫샷 167.100000 4.036489e+06 1df.groupby('성별').sum() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 키 브랜드평판지수 성별 남자 2123.2 68599637 여자 162.1 16238204 특정 열만 출력하고 싶다면? 1df.groupby('혈액형')['키'].mean() 혈액형 A 172.966667 AB 176.500000 B 183.000000 O 177.875000 Name: 키, dtype: float64 3. Multi-Index (복합 인덱스) 3-1. Multi-Index 적용 행 인덱스를 복합적으로 구성하고 싶은 경우는 인덱스를 리스트로 만들어 준다 df_name .groupby([‘col_name_1’,‘col_name_2’]) .mean() 데이터를 먼저 col_1기준으로 분류한 다음, col_2기준으로 한번 더 분류한다. 2번 분류 후의 데이터에 대해 산술통계값을 구한다 1df.groupby(['혈액형', '성별']).mean() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 키 브랜드평판지수 혈액형 성별 A 남자 175.140 7591755.20 여자 162.100 5784794.50 AB 남자 176.500 5687577.50 B 남자 183.000 3506027.00 여자 NaN 4668615.00 O 남자 177.875 3939919.75 3-2. Multi-Index 데이터 프레임을 피벗테이블로 변환 Multi-Index로 된 데이터프레임을 피벗테이블 형태로 다시 변환해줄 수 있다 df_name .unstack( ‘col_열’ ) col_열: groupby에서 선택한 두 column중 pivot table의 열인덱스로 지정해주고 싶은 column명을 입력 1df2 = df.groupby(['혈액형', '성별']).mean() 1df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 키 브랜드평판지수 혈액형 성별 A 남자 175.140 7591755.20 여자 162.100 5784794.50 AB 남자 176.500 5687577.50 B 남자 183.000 3506027.00 여자 NaN 4668615.00 O 남자 177.875 3939919.75 1df2.unstack('혈액형') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead tr th { text-align: left; } .dataframe thead tr:last-of-type th { text-align: right; } 키 브랜드평판지수 혈액형 A AB B O A AB B O 성별 남자 175.14 176.5 183.0 177.875 7591755.2 5687577.5 3506027.0 3939919.75 여자 162.10 NaN NaN NaN 5784794.5 NaN 4668615.0 NaN 1df2.unstack('성별') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead tr th { text-align: left; } .dataframe thead tr:last-of-type th { text-align: right; } 키 브랜드평판지수 성별 남자 여자 남자 여자 혈액형 A 175.140 162.1 7591755.20 5784794.5 AB 176.500 NaN 5687577.50 NaN B 183.000 NaN 3506027.00 4668615.0 O 177.875 NaN 3939919.75 NaN 3-3. 인덱스 초기화 (reset_index) reset_index() 는 Multi-Index로 구성된 데이터 프레임의 인덱스를 초기화해 준다 그 의미는 Multi-Index로 구성된 데이터 프레임 중의 index들을 dataframe의 column으로 변환시키는 것 df_name = df_name .reset_index() 1df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 키 브랜드평판지수 혈액형 성별 A 남자 175.140 7591755.20 여자 162.100 5784794.50 AB 남자 176.500 5687577.50 B 남자 183.000 3506027.00 여자 NaN 4668615.00 O 남자 177.875 3939919.75 1df2 = df2.reset_index() 1df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 혈액형 성별 키 브랜드평판지수 0 A 남자 175.140 7591755.20 1 A 여자 162.100 5784794.50 2 AB 남자 176.500 5687577.50 3 B 남자 183.000 3506027.00 4 B 여자 NaN 4668615.00 5 O 남자 177.875 3939919.75 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hyemin-kim.github.io/tags/Pandas/"},{"name":"데이터파악","slug":"데이터파악","permalink":"https://hyemin-kim.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%8C%8C%EC%95%85/"}]},{"title":"Python >> Pandas 데이터 파악 - (6) 결측값 확인 및 추출","slug":"S-Python-Pandas6","date":"2020-06-11T16:21:05.000Z","updated":"2020-06-22T10:40:54.194Z","comments":true,"path":"2020/06/12/S-Python-Pandas6/","link":"","permalink":"https://hyemin-kim.github.io/2020/06/12/S-Python-Pandas6/","excerpt":"","text":"결측값 확인 및 추출 1. 결측값에 대하여 2. column별 (비)결측값 개수 확인 – info() 3. (비)결측값 위치 확인 3-1. 전체 Data 3-2. 특정 column 4. (비)결측값 추출 4-1. 해당 column만 추출 4-2. 전체 column 추출 4-3. 지정한 column 추출 1import pandas as pd 1df = pd.read_csv('korean-idol.csv') 1. 결측값에 대하여 Null 값은 비어있는 값, 고급 언어로 결측값이다 pandas 에서는 NaN =&gt; Not a Number 로 표기 된다 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 2. column별 (비)결측값 개수 확인 – info() info() 로 각 column별의 결측값(NaN) 개수를 쉽게 확인할 수 있다. 1df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 15 entries, 0 to 14 Data columns (total 8 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 이름 15 non-null object 1 그룹 14 non-null object 2 소속사 15 non-null object 3 성별 15 non-null object 4 생년월일 15 non-null object 5 키 13 non-null float64 6 혈액형 15 non-null object 7 브랜드평판지수 15 non-null int64 dtypes: float64(1), int64(1), object(6) memory usage: 1.1+ KB 3. (비)결측값 위치 확인 .isna() .isnull() .notna() .notnull() 3-1. 전체 Data df_name .명령어 (1) 결측값 = True 1df.isna() 1df.isnull() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 False False False False False False False False 1 False False False False False False False False 2 False True False False False False False False 3 False False False False False False False False 4 False False False False False False False False 5 False False False False False False False False 6 False False False False False False False False 7 False False False False False True False False 8 False False False False False False False False 9 False False False False False False False False 10 False False False False False True False False 11 False False False False False False False False 12 False False False False False False False False 13 False False False False False False False False 14 False False False False False False False False (2) 비결측값 = True 1df.notna() 1df.notnull() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 True True True True True True True True 1 True True True True True True True True 2 True False True True True True True True 3 True True True True True True True True 4 True True True True True True True True 5 True True True True True True True True 6 True True True True True True True True 7 True True True True True False True True 8 True True True True True True True True 9 True True True True True True True True 10 True True True True True False True True 11 True True True True True True True True 12 True True True True True True True True 13 True True True True True True True True 14 True True True True True True True True 3-2. 특정 column df_name [ ‘col_name’ ] .명령어 (1) 결측값 = True 1df['그룹'].isna() 1df['그룹'].isnull() 0 False 1 False 2 True 3 False 4 False 5 False 6 False 7 False 8 False 9 False 10 False 11 False 12 False 13 False 14 False Name: 그룹, dtype: bool (2) 비결측값 = True 1df['그룹'].notna() 1df['그룹'].notnull() 0 True 1 True 2 False 3 True 4 True 5 True 6 True 7 True 8 True 9 True 10 True 11 True 12 True 13 True 14 True Name: 그룹, dtype: bool 4. (비)결측값 추출 4-1. 해당 column만 추출 결측값: df_name [ ‘col_name’] [ df_name [ ‘col_name’ ] .isna() / isnull() ] 비결측값: df_name [ ‘col_name’ ] [df_name [ ‘col_name’ ] .notna() / notnull()] 1df['그룹'][df['그룹'].isna()] 2 NaN Name: 그룹, dtype: object 1df['그룹'][df['그룹'].notnull()] 0 방탄소년단 1 빅뱅 3 방탄소년단 4 마마무 5 방탄소년단 6 뉴이스트 7 아이들 8 방탄소년단 9 핫샷 10 소녀시대 11 아스트로 12 뉴이스트 13 뉴이스트 14 방탄소년단 Name: 그룹, dtype: object 4-2. 전체 column 추출 결측값: df_name .loc [df_name [ ‘col_name’ ] .isna() / isnull() ] 비결측값: df_name .loc [df_name ['col_name] .notna() / notnull() ] 1df.loc[df['그룹'].isna()] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 1df.loc[df['그룹'].notnull()] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 4-3. 지정한 column 추출 결측값: df_name .loc [df_name [ ‘na_col_name’ ] .isna() / isnull() , [‘col_name1’, ‘col_name2’, …]] 비결측값: df_name .loc [df_name ['na_col_name] .notna() / notnull() , [‘col_name1’, ‘col_name2’, …]] 1df.loc[df['그룹'].isna(), ['이름', '소속사']] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 소속사 2 강다니엘 커넥트 1df.loc[df['그룹'].notnull(), ['이름', '소속사']] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 소속사 0 지민 빅히트 1 지드래곤 YG 3 뷔 빅히트 4 화사 RBW 5 정국 빅히트 6 민현 플레디스 7 소연 큐브 8 진 빅히트 9 하성운 스타크루이엔티 10 태연 SM 11 차은우 판타지오 12 백호 플레디스 13 JR 플레디스 14 슈가 빅히트 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hyemin-kim.github.io/tags/Pandas/"},{"name":"데이터파악","slug":"데이터파악","permalink":"https://hyemin-kim.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%8C%8C%EC%95%85/"}]},{"title":"Python >> Pandas 데이터 파악 - (5) 범위선택","slug":"S-Python-Pandas5","date":"2020-05-24T12:58:03.000Z","updated":"2020-06-22T10:40:48.309Z","comments":true,"path":"2020/05/24/S-Python-Pandas5/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/24/S-Python-Pandas5/","excerpt":"","text":"범위선택 1. 단일 column을 선택하는 방법 2. index &amp; column 범위 선택 (range selection) 2-1. 단순 index에 대한 범위 선택 2-2. index &amp; column 범위선택 – loc 2-3. index &amp; column 범위선택 – iloc (position으로 색인) 3. index &amp; column 조건범위선택 – Boolean Indexing 3-1. 조건에 만족한 row들의 모든 column을 추출 3-2. 조건에 만족한 row들의 특정 column들을 추출 4. index &amp; column 조건범위선택 – inis을 활용란 색인 1import pandas as pd 1df = pd.read_csv('korean-idol.csv') 1. 단일 column을 선택하는 방법 df_name [ 'col_name ’ ] df_name [ \"col_name \" ] df_name .col_name 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1df['이름'] 1df[\"이름\"] 1df.이름 0 지민 1 지드래곤 2 강다니엘 3 뷔 4 화사 5 정국 6 민현 7 소연 8 진 9 하성운 10 태연 11 차은우 12 백호 13 JR 14 슈가 Name: 이름, dtype: object 2. index &amp; column 범위 선택 (range selection) 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 2-1. 단순 index에 대한 범위 선택 1df[:3] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 1df.head(3) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 2-2. index &amp; column 범위선택 – loc df_name .loc [행(index) 범위, (열)column 범위] 행 범위는 “:” “:b” “a:b” 등 형식을 사용 열 범위는 'column name ’ ['column name1 ', 'column name2 '] 'column name1 ’ : 'column name2 ’ 등 형식을 사용 주의: pandas의 loc에서 범위 a : b는 index a &amp; index b 모두 포함 numpy에서는 index a 포함, index b 미포함 1df.loc[:, '이름'] 0 지민 1 지드래곤 2 강다니엘 3 뷔 4 화사 5 정국 6 민현 7 소연 8 진 9 하성운 10 태연 11 차은우 12 백호 13 JR 14 슈가 Name: 이름, dtype: object 1df.loc[:, ['이름', '생년월일']] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 생년월일 0 지민 1995-10-13 1 지드래곤 1988-08-18 2 강다니엘 1996-12-10 3 뷔 1995-12-30 4 화사 1995-07-23 5 정국 1997-09-01 6 민현 1995-08-09 7 소연 1998-08-26 8 진 1992-12-04 9 하성운 1994-03-22 10 태연 1989-03-09 11 차은우 1997-03-30 12 백호 1995-07-21 13 JR 1995-06-08 14 슈가 1993-03-09 1df.loc[3:8, ['이름', '생년월일']] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 생년월일 3 뷔 1995-12-30 4 화사 1995-07-23 5 정국 1997-09-01 6 민현 1995-08-09 7 소연 1998-08-26 8 진 1992-12-04 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1df.loc[2:5, '이름':'생년월일'] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 2 강다니엘 NaN 커넥트 남자 1996-12-10 3 뷔 방탄소년단 빅히트 남자 1995-12-30 4 화사 마마무 RBW 여자 1995-07-23 5 정국 방탄소년단 빅히트 남자 1997-09-01 2-3. index &amp; column 범위선택 – iloc (position으로 색인) 행(index) 범위 선택은 loc와 동일 열(column) 범위는 'column 명’대신 column position을 사용 행 범위는 “:” “:b” “a:b” 등 형식을 사용 열 범위는 “c” “[c, d]” “c:d” 등 형식을 사용 주의: pandas의 iloc에서 범위 a : b는 index a 포함, index b 미포함 (numpy와 동일) pandas의 loc에서 범위 a : b는 index a &amp; index b 모두 포함 1df.iloc[:, [0, 2]] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 소속사 0 지민 빅히트 1 지드래곤 YG 2 강다니엘 커넥트 3 뷔 빅히트 4 화사 RBW 5 정국 빅히트 6 민현 플레디스 7 소연 큐브 8 진 빅히트 9 하성운 스타크루이엔티 10 태연 SM 11 차은우 판타지오 12 백호 플레디스 13 JR 플레디스 14 슈가 빅히트 1df.iloc[1:5, [0, 2]] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 소속사 1 지드래곤 YG 2 강다니엘 커넥트 3 뷔 빅히트 4 화사 RBW 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1df.iloc[1:5, 0:4] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 1 지드래곤 빅뱅 YG 남자 2 강다니엘 NaN 커넥트 남자 3 뷔 방탄소년단 빅히트 남자 4 화사 마마무 RBW 여자 3. index &amp; column 조건범위선택 – Boolean Indexing Boolean indexing은 Numpy에서의 Boolean indexing과 같은 원리다 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 3-1. 조건에 만족한 row들의 모든 column을 추출 df [조건 ] 1df['키'] &gt; 180 0 False 1 False 2 False 3 False 4 False 5 False 6 True 7 False 8 False 9 False 10 False 11 True 12 False 13 False 14 False Name: 키, dtype: bool 1df[df['키'] &gt; 180] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 3-2. 조건에 만족한 row들의 특정 column들을 추출 방법 1. df_name [조건 ] [column범위 ] 1df[ df['키'] &gt; 180 ] ['이름'] 6 민현 11 차은우 Name: 이름, dtype: object 1df [ df['키'] &gt; 180 ] [['이름', '키']] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 키 6 민현 182.3 11 차은우 183.0 방법 2. loc를 활용: df_name.loc[ 조건 , column범위 ] 【추천】 1df.loc[ df['키'] &gt; 180, '이름' ] 6 민현 11 차은우 Name: 이름, dtype: object 1df.loc[ df['키'] &gt; 180, ['이름', '그룹'] ] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 6 민현 뉴이스트 11 차은우 아스트로 1df.loc[ df['키'] &gt; 180, '이름' : '성별'] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 6 민현 뉴이스트 플레디스 남자 11 차은우 아스트로 판타지오 남자 4. index &amp; column 조건범위선택 – inis을 활용란 색인 column값이 미리 정의한 list에 속한다는 조건을 걸고자 할 때 사용한다 1my_condition = ['플레디스', 'SM'] 1df['소속사'].isin(my_condition) 0 False 1 False 2 False 3 False 4 False 5 False 6 True 7 False 8 False 9 False 10 True 11 False 12 True 13 True 14 False Name: 소속사, dtype: bool 1df.loc[ df['소속사'].isin(my_condition) ] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 1df.loc[ df['소속사'].isin(my_condition) , ['이름', '소속사'] ] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 소속사 6 민현 플레디스 10 태연 SM 12 백호 플레디스 13 JR 플레디스 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hyemin-kim.github.io/tags/Pandas/"},{"name":"데이터파악","slug":"데이터파악","permalink":"https://hyemin-kim.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%8C%8C%EC%95%85/"}]},{"title":"Python >> Pandas 데이터 파악 - (4) 정렬","slug":"S-Python-Pandas4","date":"2020-05-24T08:07:08.000Z","updated":"2020-06-22T10:40:43.872Z","comments":true,"path":"2020/05/24/S-Python-Pandas4/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/24/S-Python-Pandas4/","excerpt":"","text":"정렬 (sort) 1. index 순으로 정렬 2. column의 value순으로 정렬 2-1. 단일 column 기준 2-2. 복수 column 기준 1import pandas as pd 1df = pd.read_csv('korean-idol.csv') 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 1. index 순으로 정렬 오름차순 정렬: df_name.sort_index() (default) 내림차순 정렬: df_name.sort_index(ascending = False) 1df.sort_index() # 오름차순 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 1df.sort_index(ascending = False) # 내림차순 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 2. column의 value순으로 정렬 오름차순 정렬: df_name.sort_values(by = ‘col_name’) 내림차순 정렬: df_name.sort_values(by = ‘col_name’, ascending = False) 2-1. 단일 column 기준 1df.sort_values(by='키') # 오름차순 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 1df.sort_values(by = '키', ascending = False) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 2-2. 복수 column 기준 먼저 column1 기준으로 정렬하고, column1 값이 동일한 row들은 column2기준으로 정렬: df_name .sort_value ( by = [ ‘col_name 1’ , ‘col_name 2’ ] ) 1df.sort_values(by = ['키', '브랜드평판지수']) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 1df.sort_values(by = ['키', '브랜드평판지수'], ascending = False) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hyemin-kim.github.io/tags/Pandas/"},{"name":"데이터파악","slug":"데이터파악","permalink":"https://hyemin-kim.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%8C%8C%EC%95%85/"}]},{"title":"Python >> Pandas 데이터 파악 - (3) 기본정보 & 통계정보 파악","slug":"S-Python-Pandas3","date":"2020-05-24T08:06:08.000Z","updated":"2020-06-22T10:40:38.514Z","comments":true,"path":"2020/05/24/S-Python-Pandas3/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/24/S-Python-Pandas3/","excerpt":"","text":"기본정보 &amp; 통계정보 파악 1. 파일 읽어오기 (csv) 2. 기본 행&amp;열 정보 알아보기 (column, index, info) 2-1. column (열) 이름 출력하기 2-2. column (열) 이름 재정의하기 2-3. index (행) 정보 출력하기 2-4. info (기본적인 column 정보와 데이터 타입) 3. 형태 (shape) 알아보기 4. 상위 5개, 하위 5개의 정보만 보기 5. 통계 정보 알아보기 5-1. 전체 통계 정보 5-2. 최소값(min), 최대값(max), 중앙값(median), 최빈값(mode) 5-3. 합계(sum), 평균(mean), 분산(var), 표준편차(std) 5-4. 갯수를 세는 count 1import pandas as pd 1. 파일 읽어오기 (csv) 1df = pd.read_csv('korean-idol.csv') 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 2. 기본 행&amp;열 정보 알아보기 (column, index, info) 2-1. column (열) 이름 출력하기 df_name .columns 1df.columns Index(['이름', '그룹', '소속사', '성별', '생년월일', '키', '혈액형', '브랜드평판지수'], dtype='object') ​ 2-2. column (열) 이름 재정의하기 (1) 전체 column 이름 df_name .columns = […] 예: “이름” --&gt; “name”: 1new_col = ['name', '그룹', '소속사', '성별', '생년월일', '키', '혈액형', '브랜드평판지수'] 1df.columns = new_col 1df.columns Index(['name', '그룹', '소속사', '성별', '생년월일', '키', '혈액형', '브랜드평판지수'], dtype='object') ​ (2) 개별 column 이름 df_name .rename ( columns = { “old_name” : “new_name” } ) ​ 1df = pd.read_csv('korean-idol.csv') 1df.columns Index(['이름', '그룹', '소속사', '성별', '생년월일', '키', '혈액형', '브랜드평판지수'], dtype='object') ​ 1df = df.rename(columns = {\"이름\" : \"name\"}) 1df.columns Index(['name', '그룹', '소속사', '성별', '생년월일', '키', '혈액형', '브랜드평판지수'], dtype='object') ​ 2-3. index (행) 정보 출력하기 df_name .index 1df.index RangeIndex(start=0, stop=15, step=1) 2-4. info (기본적인 column 정보와 데이터 타입) df_name .info() Tip: info메소드는 주로 빠진 값 (null 값)과 데이터 타입을 볼 때 활용함 1df.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 15 entries, 0 to 14 Data columns (total 8 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 name 15 non-null object 1 그룹 14 non-null object 2 소속사 15 non-null object 3 성별 15 non-null object 4 생년월일 15 non-null object 5 키 13 non-null float64 6 혈액형 15 non-null object 7 브랜드평판지수 15 non-null int64 dtypes: float64(1), int64(1), object(6) memory usage: 1.1+ KB “object” type은 주로 문자형 데이터를 가리킴. 3. 형태 (shape) 알아보기 shape는 tuple형태로 반환되며, 첫번째는 row, 두번째는 column의 숫자를 의미함. 1df.shape (15, 8) 4. 상위 5개, 하위 5개의 정보만 보기 상위 5개 row: df_name .head() 하위 5개 row: df_name .tail() 상위 n개 row: df_name .head(n) 하위 n개 row: df_name .tail(n) 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1df.tail() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 1df.head(3) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 1df.tail(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 5. 통계 정보 알아보기 통계값은 산술 연산이 가능한 숫자형 (float / int) 인 column을 다룬다 5-1. 전체 통계 정보 df_name .describe() 산술 연산이 가능한 column만 출력됨 1df.describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 키 브랜드평판지수 count 13.000000 1.500000e+01 mean 175.792308 5.655856e+06 std 5.820576 2.539068e+06 min 162.100000 2.925442e+06 25% 174.000000 3.712344e+06 50% 177.000000 4.668615e+06 75% 179.200000 7.862214e+06 max 183.000000 1.052326e+07 5-2. 최소값(min), 최대값(max), 중앙값(median), 최빈값(mode) 최소값: df_name [ ‘col_name’ ] .min() 최대값: df_name [ ‘col_name’ ] .max() 중앙값: df_name [ ‘col_name’ ] .median() 최빈값: df_name [ ‘col_name’ ] .mode() 1df['키'].min() 162.1 1df['키'].max() 183.0 1df['키'].median() 177.0 1df['키'].mode() 0 178.0 dtype: float64 5-3. 합계(sum), 평균(mean), 분산(var), 표준편차(std) 합계(sum): df_name [ ‘col_name’ ] .sum() 평균(mean): df_name [ ‘col_name’ ] .mean() 분산(variance): df_name [ ‘col_name’ ] .var() 표준편차(standard deviation): df_name [ ‘col_name’ ] .std() 1df['키'].sum() 2285.3 1df['키'].mean() 175.7923076923077 1df['키'].var() 33.879102564102595 1df['키'].std() 5.820575793175672 5-4. 갯수를 세는 count df_name [ ‘col_name’ ] .count 1df['키'].count() 13 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hyemin-kim.github.io/tags/Pandas/"},{"name":"데이터파악","slug":"데이터파악","permalink":"https://hyemin-kim.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%8C%8C%EC%95%85/"}]},{"title":"Python >> Pandas 데이터 파악 - (2) 파일 불러오기 및 복사","slug":"S-Python-Pandas2","date":"2020-05-24T06:04:59.000Z","updated":"2020-06-22T10:40:30.614Z","comments":true,"path":"2020/05/24/S-Python-Pandas2/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/24/S-Python-Pandas2/","excerpt":"","text":"파일 불러오기 및 복사 1. csv파일 읽어오기 – \"pd.read_csv\" 1-1. Jupyter Notebook 기반 1-2. Colab 기반 2. Excle파일 읽어오기 – \"pd.read_excel\" 2-1. Jupyter Notebook 기반 2-2. Colab 기반 3. 복사 (copy) 1. csv파일 읽어오기 – \"pd.read_csv\" 1-1. Jupyter Notebook 기반 1import pandas as pd 1pd.read_csv('korean-idol.csv') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 1-2. Colab 기반 방법 1. 로컬에서 파일 읽어오기 123456from google.colab import filesmyfile = files.upload()import iopd.read_csv(io.BytesIO(myfile['korean-idol.csv'])) 방법 2: 구글 드라이브에 있는 샘플 파일 읽어오기 123456789from google.colab import drivedrive.mount('/content/drive')# 나타나는 link에 따라 google drive 로그인하여 link복사, # 'Enter your authorization code:'에서 복사된 link를 입력filename = 'colab 왼쪽 목록에서 파일 경로를 복사하여 붙혀놓기'pd.read_csv(filename) 2. Excle파일 읽어오기 – \"pd.read_excel\" 2-1. Jupyter Notebook 기반 1pd.read_excel('korean-idol.xlsx') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 5 정국 방탄소년단 빅히트 남자 1997-09-01 178.0 A 5208335 6 민현 뉴이스트 플레디스 남자 1995-08-09 182.3 O 4989792 7 소연 아이들 큐브 여자 1998-08-26 NaN B 4668615 8 진 방탄소년단 빅히트 남자 1992-12-04 179.2 O 4570308 9 하성운 핫샷 스타크루이엔티 남자 1994-03-22 167.1 A 4036489 10 태연 소녀시대 SM 여자 1989-03-09 NaN A 3918661 11 차은우 아스트로 판타지오 남자 1997-03-30 183.0 B 3506027 12 백호 뉴이스트 플레디스 남자 1995-07-21 175.0 AB 3301654 13 JR 뉴이스트 플레디스 남자 1995-06-08 176.0 O 3274137 14 슈가 방탄소년단 빅히트 남자 1993-03-09 174.0 O 2925442 2-2. Colab 기반 구글 드라이브에 있는 샘플 파일 읽어오기 123456from google.colab import drivedrive.mount('/content/drive')filename = '파일 경로 붙혀놓기'pd.read_excel(filename) 3. 복사 (copy) dataframe을 복사할 때 \"df_name.copy()\"를 사용한다 \"=\"를 사용하여 원본데이터를 \"복사\"하면 복사된 데이터를 수정할 때 원본 데이터도 같이 변화한다 1df = pd.read_csv('korean-idol.csv') 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1df_new = df 1df_new.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1df_new['이름'] = 0 1df_new.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 0 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 0 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 0 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 0 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 0 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 0 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 0 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 0 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 0 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 0 마마무 RBW 여자 1995-07-23 162.1 A 7650928 이렇게 되는 이유는 두 dataframe이 같은 메모리 주소를 참조하기 때문이다. 1hex(id(df_new)) '0x25109f6e6c8' 1hex(id(df)) '0x25109f6e6c8' 원본 데이터를 유지 시키고, 새로운 변수에 복사할 때 copy() 를 사용한다 1df = pd.read_csv('korean-idol.csv') 1df_copy = df.copy() 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1df_copy.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 복사된 dataframe이 원본 데이터와 같은 메모리 주소를 참조한다. 1hex(id(df)) '0x25109fefa48' 1hex(id(df_copy)) '0x25109ff4408' copy본을 수정할 때 원본 데이터가 유지된다 1df_copy['이름'] = 0 1df_copy.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 0 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 0 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 0 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 0 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 0 마마무 RBW 여자 1995-07-23 162.1 A 7650928 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 이름 그룹 소속사 성별 생년월일 키 혈액형 브랜드평판지수 0 지민 방탄소년단 빅히트 남자 1995-10-13 173.6 A 10523260 1 지드래곤 빅뱅 YG 남자 1988-08-18 177.0 A 9916947 2 강다니엘 NaN 커넥트 남자 1996-12-10 180.0 A 8273745 3 뷔 방탄소년단 빅히트 남자 1995-12-30 178.0 AB 8073501 4 화사 마마무 RBW 여자 1995-07-23 162.1 A 7650928 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hyemin-kim.github.io/tags/Pandas/"},{"name":"데이터파악","slug":"데이터파악","permalink":"https://hyemin-kim.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%8C%8C%EC%95%85/"}]},{"title":"Python >> Pandas 데이터 파악 - (1) Series와 DataFrame","slug":"S-Python-Pandas1","date":"2020-05-22T11:37:46.000Z","updated":"2020-06-22T10:40:23.429Z","comments":true,"path":"2020/05/22/S-Python-Pandas1/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/22/S-Python-Pandas1/","excerpt":"","text":"Series &amp; DataFrame 1. pandas 패키지 로드 2. pandas의 Series 와 DataFrame 2-1. Series 2-2. DataFrame 방법 1. list로 만들기 방법 2. dict로 만들기 2-3. index를 특정column으로 지정하기 2-4. column = Series 1. pandas 패키지 로드 1import pandas 별칭은 주로 pd로 사용한다 1import pandas as pd 1pd &lt;module 'pandas' from 'D:\\\\Anaconda\\\\lib\\\\site-packages\\\\pandas\\\\__init__.py'&gt; 2. pandas의 Series 와 DataFrame 1차원, 1개의 column은 Series라고 한다 2-1. Series Series 생성: pd.Series(“list”) pd.Series(“list_name”) (1) pd.Series(“list”) 1pd.Series([1, 2, 3, 4]) 0 1 1 2 2 3 3 4 dtype: int64 (2) pd.Series(“list_name”) 1a = [1, 2, 3, 4] 1pd.Series(a) 0 1 1 2 2 3 3 4 dtype: int64 1mylist = [1, 2, 3, 4] 1pd.Series(mylist) 0 1 1 2 2 3 3 4 dtype: int64 2-2. DataFrame 방법 1. list로 만들기 123company1 = [['삼성', 2000, '스마트폰'], ['현대', 1000, '자동차'], ['네이버', 500, '포털']] 1pd.DataFrame(company1) .dataframe tbody tr th:only-of-type { vertical-align: middle } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 0 삼성 2000 스마트폰 1 현대 1000 자동차 2 네이버 500 포털 &lt;활용을 하기 위해 DataFrame을 변수에 지정하기&gt; 1df1 = pd.DataFrame(company1) 1df1 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 0 삼성 2000 스마트폰 1 현대 1000 자동차 2 네이버 500 포털 &lt;제목컬럼 만들기&gt; – “dfname.column = [ ]” 1df1.columns = ['기업명', '매출액', '업종'] 1df1 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 기업명 매출액 업종 0 삼성 2000 스마트폰 1 현대 1000 자동차 2 네이버 500 포털 주의: column명의 개수는 반드시 DataFrame의 column수와 동일해야 함 방법 2. dict로 만들기 1234company2 = {'기업명': ['삼성', '현대', '네이버'], '매출액': [2000, 1000, 500], '업종': ['스므트폰', '자동차', '포털'] } 1df2 = pd.DataFrame(company2) 1df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 기업명 매출액 업종 0 삼성 2000 스므트폰 1 현대 1000 자동차 2 네이버 500 포털 2-3. index를 특정column으로 지정하기 “dfname.index = [ ]” 명령을 사용한다 1df1 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 기업명 매출액 업종 0 삼성 2000 스마트폰 1 현대 1000 자동차 2 네이버 500 포털 1df1.index = df1['기업명'] 1df1 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 기업명 매출액 업종 기업명 삼성 삼성 2000 스마트폰 현대 현대 1000 자동차 네이버 네이버 500 포털 2-4. column = Series 1df1['매출액'] 기업명 삼성 2000 현대 1000 네이버 500 Name: 매출액, dtype: int64 1type(df1['매출액']) pandas.core.series.Series document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hyemin-kim.github.io/tags/Pandas/"},{"name":"데이터파악","slug":"데이터파악","permalink":"https://hyemin-kim.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%8C%8C%EC%95%85/"}]},{"title":"Python >> Numpy - (4) 행렬. Broadcasting","slug":"S-Python-Numpy4","date":"2020-05-20T07:55:34.000Z","updated":"2020-06-11T17:09:58.983Z","comments":true,"path":"2020/05/20/S-Python-Numpy4/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/20/S-Python-Numpy4/","excerpt":"행렬 (덧셈, 뺄셈, 곱셈). Broadcasting.","text":"행렬 (덧셈, 뺄셈, 곱셈). Broadcasting. 목록 1. 행렬 - 덧셈 1-1. 덧셈 1-2. Sum – Matrix안의 계산 2. 행렬 - 뺄셈 3. 행렬 - 곱셈 3-1. 일반 곱셈 3-2. dot product / 내적곱 4. Broadcasting 4-1. 숫자의 연산 4-2. array (배열)의 broadcasting 1import numpy as np 1. 행렬 - 덧셈 행렬의 shape이 같아야 덧셈 가능 1-1. 덧셈 12a = np.array([[1, 2, 3], [2, 3, 4]]) 12b = np.array([[3, 4, 5], [1, 2, 3]]) 1a + b array([[4, 6, 8], [3, 5, 7]]) 12a = np.array([[1, 2, 3], [2, 3, 4]]) 123b = np.array([[1, 2], [3, 4], [5, 6]]) 1a + b # shape이 다르면 error발생 --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-7-37f7d36ad418&gt; in &lt;module&gt; ----&gt; 1 a + b # shape이 다르면 error발생 ValueError: operands could not be broadcast together with shapes (2,3) (3,2) 1-2. Sum – Matrix안의 계산 명령어: np.sum(‘array_name’, axis = ‘0/1/…’) 주의: 계산할 때 axis의 방향대로 Sum을 구한다. 예를 들면, 2darray에서, axis = 0 이면: 수직방향으로 Sum을 구한다 axis = 1 이면: 수평방향으로 Sum을 구한다 12a = np.array([[1, 2, 3], [2, 3, 4]]) 1np.sum(a, axis = 0) array([3, 5, 7]) 1np.sum(a, axis = 1) array([6, 9]) 2. 행렬 - 뺄셈 12a = np.array([[1, 2, 3], [2, 3, 4]]) 12b = np.array([[3, 4, 5], [1, 2, 3]]) 1a - b array([[-2, -2, -2], [ 1, 1, 1]]) 12a = np.array([[1, 2, 3], [2, 3, 4]]) 123b = np.array([[1, 2], [3, 4], [5, 6]]) 1a - b # shape이 다르면 error발생 --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-18-e62ba154daaa&gt; in &lt;module&gt; ----&gt; 1 a - b # shape이 다르면 error발생 ValueError: operands could not be broadcast together with shapes (2,3) (3,2) 3. 행렬 - 곱셈 3-1. 일반 곱셈 일반곱셈은 덧셈과 뺏셈이랑 동일하게 같은 위치에 있는 애들끼리 곱한다. [shape이 완전 같아야 함] 12a = np.array([[1, 2, 3], [2, 3, 4]]) 12b = np.array([[3, 4, 5], [1, 2, 3]]) 1a * b array([[ 3, 8, 15], [ 2, 6, 12]]) 3-2. dot product / 내적곱 [맞닿는 shape이 같아야 함] 12a = np.array([[1, 2, 3], [2, 3, 4]]) 123b = np.array([[1, 2], [3, 4], [5, 6]]) 1a.shape, b.shape ((2, 3), (3, 2)) 방법 1: np.dot(a, b) 1np.dot(a, b) array([[22, 28], [31, 40]]) 방법2: a.dot(b) 1a.dot(b) array([[22, 28], [31, 40]]) 4. Broadcasting 4-1. 숫자의 연산 array a 의 모든 원소에 3을 더하고 싶다면: 단순히 행렬 덧셈을 사용할 때: 12a = np.array([[1, 2, 3], [2, 3, 4]]) 12b = np.array([[3, 3, 3], [3, 3, 3]]) 1a + b array([[4, 5, 6], [5, 6, 7]]) Broadcasting 사용할 때: 12a = np.array([[1, 2, 3], [2, 3, 4]]) 1a + 3 array([[4, 5, 6], [5, 6, 7]]) 1a - 3 array([[-2, -1, 0], [-1, 0, 1]]) 1a * 3 array([[ 3, 6, 9], [ 6, 9, 12]]) 1a / 3 array([[0.33333333, 0.66666667, 1. ], [0.66666667, 1. , 1.33333333]]) 4-2. array (배열)의 broadcasting original array의 shape이 유지됨. 12a = np.array([[1, 2, 3], [2, 3, 4]]) 12b = np.array([[1], [2]]) 1a.shape, b.shape ((2, 3), (2, 1)) 1a * b array([[1, 2, 3], [4, 6, 8]]) 12a = np.array([[1, 2, 3], [2, 3, 4]]) 1b = np.array([1, 2, 3]) 1a * b array([[ 1, 4, 9], [ 2, 6, 12]]) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"https://hyemin-kim.github.io/tags/Numpy/"}]},{"title":"Python >> Numpy - (3) 수열. 정렬","slug":"S-Python-Numpy3","date":"2020-05-19T17:10:54.000Z","updated":"2020-06-11T17:09:51.726Z","comments":true,"path":"2020/05/20/S-Python-Numpy3/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/20/S-Python-Numpy3/","excerpt":"arange. range. 정렬(sort &amp; argsort)","text":"arange. range. 정렬(sort &amp; argsort) 목록 1. arange란? 1-1. 순서대로 리스트에 값을 생성하려면? 1-2. arange를 사용해서 쉽게 생성하기 1-3. keyword인자를 사용해보기 1-4. 홀수의 값만 생성 2. range (Numpy와는 상관없는 Python문법) 3. 정렬 3-1. 1차원 정렬 3-2. N차원 정렬 3-3. index를 반환하는 argsort 1import numpy as np 1. arange란? arange와 range를 같이 보고 이해하면 됨 [실제 상황 예시] 우리는 순차적인 값을 생성할 때가 많다. 예를 들면: 회원에 대한 가입번호 부여 100개 한정 판매 상품에 대한 고유 번호 부여 이 밖에도 데이터 관리를 위한 인덱스를 차례대로 부여하는 것은 매우 흔한 일이다. 1-1. 순서대로 리스트에 값을 생성하려면? 1~10까지 값을 생성하려면? 1arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 1arr [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 1-2. arange를 사용해서 쉽게 생성하기 np.arange(a, b): a 부터 b-1 까지 생성한다 (a포함, b미포함) 1arr = np.arange(1, 11) 1arr array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 1-3. keyword인자를 사용해보기 np.arange(start = a, stop = b) 1arr = np.arange(start=1, stop=11) 1arr array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 1arr = np.arange(stop=11, start=1) # start &amp; stop 지정했기 때문에 순서 바꿔도 됨 1arr array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 1arr = np.arange(11,1) # start &amp; stop 지정 안하면 순서 바꿨을 때 오류 남 1arr array([], dtype=int32) 1-4. 홀수의 값만 생성 1~10 사이의 값중 홀수만 생성 step 키워드 활용 np.arange(start, stop, step) 1arr = np.arange(1, 11, 2) 1arr array([1, 3, 5, 7, 9]) 1arr = np.arange(start=1, stop=11, step=2) 1arr array([1, 3, 5, 7, 9]) 2. range (Numpy와는 상관없는 Python문법) range는 말 그대로 범위를 지정해 주는 것이다 보통 for-in 의 반복문에서 많이 사용된다 arange와는 다르게 array형태로 저장되어있지 않고 그냥 가볍게 바로바로 쓴다 arange 구문 활용시 1arr = np.arange(1, 11) 1arr array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 12for i in arr: print(i) 1 2 3 4 5 6 7 8 9 10 range 구문 활용시 12for i in range(1, 11): print(i) 1 2 3 4 5 6 7 8 9 10 12for i in range(1, 11, 2): print(i) 1 3 5 7 9 3. 정렬 3-1. 1차원 정렬 1차원 정렬은 매우 간단함 오름차순으로 정렬: np.sort(arr) 내림차순으로 정렬: np.sort(arr)[::-1] 1arr = np.array([1, 10, 5, 8, 2, 4, 3, 6, 8, 7, 9]) 1arr array([ 1, 10, 5, 8, 2, 4, 3, 6, 8, 7, 9]) 1np.sort(arr) array([ 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 10]) 1np.sort(arr)[::-1] array([10, 9, 8, 8, 7, 6, 5, 4, 3, 2, 1]) 하지만, 그냥 이상태에서는 정렬된 이 값들이 유지가 안됨 값을 sort 된 상태로 유지시키려면: 변수로 다시 지정해주기 np.sort(arr) 대신 arr.sort() 쓴다 [arr자체에 sort명령을 씌워줌] 1arr array([ 1, 10, 5, 8, 2, 4, 3, 6, 8, 7, 9]) 1np.sort(arr) array([ 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 10]) 1arr # np.sort 만 실행했을 때 유지가 안됨 array([ 1, 10, 5, 8, 2, 4, 3, 6, 8, 7, 9]) 1arr2 = np.sort(arr) # 방법1: arr2로 지정하기 1arr2 array([ 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 10]) 1arr.sort() # 방법2: arr.sort 사용하기 1arr array([ 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 10]) 3-2. N차원 정렬 N차원 정렬에서는 axis 중요함. (즉, 정렬 기준이 되는 축) 123arr2d = np.array([[5, 6, 7, 8], [4, 3, 2, 1], [10, 9, 12, 11]]) 1arr2d.shape (3, 4) 열 정렬 (왼쪽에서 오른쪽으로 정렬) – axis 1을 기준으로 삼 1arr2d # 정렬 전 array([[ 5, 6, 7, 8], [ 4, 3, 2, 1], [10, 9, 12, 11]]) 1np.sort(arr2d, axis = 1) # 정렬 후 array([[ 5, 6, 7, 8], [ 1, 2, 3, 4], [ 9, 10, 11, 12]]) 행 정렬 (위에서 아래로 정렬) – axis 0을 기준으로 삼 1arr2d # 정렬 전 array([[ 5, 6, 7, 8], [ 4, 3, 2, 1], [10, 9, 12, 11]]) 1np.sort(arr2d, axis = 0) # 정렬 후 array([[ 4, 3, 2, 1], [ 5, 6, 7, 8], [10, 9, 12, 11]]) 3-3. index를 반환하는 argsort 정렬한 결과에는 값을 반환하는 것이 아닌 index를 반환한다 열 정렬 (왼쪽에서 오른쪽으로 정렬) 1arr2d # 정렬 전 array([[ 5, 6, 7, 8], [ 4, 3, 2, 1], [10, 9, 12, 11]]) 1np.sort(arr2d, axis = 1) # sort 정렬 후 array([[ 5, 6, 7, 8], [ 1, 2, 3, 4], [ 9, 10, 11, 12]]) 1np.argsort(arr2d, axis = 1) # argsort 정렬 후 array([[0, 1, 2, 3], [3, 2, 1, 0], [1, 0, 3, 2]], dtype=int64) 행 정렬 (위에서 아래로 정렬) 1arr2d # 정렬 전 array([[ 5, 6, 7, 8], [ 4, 3, 2, 1], [10, 9, 12, 11]]) 1np.sort(arr2d, axis = 0) # sort 정렬 후 array([[ 4, 3, 2, 1], [ 5, 6, 7, 8], [10, 9, 12, 11]]) 1np.argsort(arr2d, axis = 0) # argsort 정렬 후 array([[1, 1, 1, 1], [0, 0, 0, 0], [2, 2, 2, 2]], dtype=int64) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"https://hyemin-kim.github.io/tags/Numpy/"}]},{"title":"Python >> Numpy - (2) Slicing. 인덱싱","slug":"S-Python-Numpy2","date":"2020-05-19T12:55:06.000Z","updated":"2020-06-11T17:09:45.587Z","comments":true,"path":"2020/05/19/S-Python-Numpy2/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/19/S-Python-Numpy2/","excerpt":"슬라이싱 (Slicing). Fancy 인덱싱. Boolean 인덱싱.","text":"슬라이싱 (Slicing). Fancy 인덱싱. Boolean 인덱싱. 목록 1. 슬라이싱 (Slicing) 1-1. index 지정하여 색인 1차원 array 2차원 array 1-2. 범위 색인 1차원 array 2차원 array 2. Fancy 인덱싱 2-1. 1차원 array 2-2. 2차원 array 3. Boolean 인덱싱 3-1. True와 False값으로 색인하기 3-2. 조건필터 1. 슬라이싱 (Slicing) 1import numpy as np 베열의 부분 선택 (과일을 슬라이스해서 부분만 먹듯…) 1arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1arr.shape (10,) 1-1. index 지정하여 색인 1차원 array 1arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1arr[0] # index: 앞에서 부터 0, 1, 2, ... 0 1arr[5] 5 1arr[10] # index가 넘으면 error남 --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-7-ff656e92d79c&gt; in &lt;module&gt; ----&gt; 1 arr[10] IndexError: index 10 is out of bounds for axis 0 with size 10 1arr[-1] # 뒤에서 부터 1번째. index: 뒤에서 부터 -1, -2, -3,... 9 1arr[-10] 0 1arr[-11] --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-10-91f133f07612&gt; in &lt;module&gt; ----&gt; 1 arr[-11] IndexError: index -11 is out of bounds for axis 0 with size 10 2차원 array 123arr2d = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) 1arr2d.shape (3, 4) arr2d[행, 열] 1arr2d[0, 2] 3 1arr2d[2, 1] 10 1-2. 범위 색인 1차원 array arr[a, b] – arr의 “index a” 부터 \"index b-1\"까지 (a 포함, b 미포함) index: 1 이상 1arr array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1arr[1:] # index 1 포함 array([1, 2, 3, 4, 5, 6, 7, 8, 9]) index: 5 미만 1arr[:5] # index 5 미포함 array([0, 1, 2, 3, 4]) index: 1이상 5미만 1arr[1:5] # index 1 포함 &amp; index 5 미포함 array([1, 2, 3, 4]) index: -1까지 1arr[:-1] # index -1 (index 9) 미포함 array([0, 1, 2, 3, 4, 5, 6, 7, 8]) 2차원 array 123arr2d = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) row(행)을 모두 가져오려는 경우 1arr2d[0,:] # 0번 행의 모든 열 가져오기 array([1, 2, 3, 4]) colomn(열)을 모두 가져오려는 경우 1arr2d[:,2] array([ 3, 7, 11]) 부분적으로 가져오려는 경우 1arr2d[:2, :] # 0,1번 행의 모든 열 가져오기 array([[1, 2, 3, 4], [5, 6, 7, 8]]) 1arr2d[:2, 2:] # 0,1번 행의 2,3번 열 가져오기 array([[3, 4], [7, 8]]) 2. Fancy 인덱싱 fancy인덱싱은 범위가 아닌 특정 index의 집합의 값을 선택하여 추출하고 싶을 때 활용한다 1arr = np.array([10, 23, 2, 7, 90, 65, 32, 66, 70]) 2-1. 1차원 array 방법 1: 추출하고 싶은 index의 집합을 **[꺾쇠 괄호로]**묶어서 추출 1arr[[1, 3, 5]] array([23, 7, 65]) 방법 2: 추출하고 싶은 index의 집합을 변수에 지정한 후 추출 1idx = [1, 3, 5] 1arr[index] array([23, 7, 65]) 2-2. 2차원 array 123arr2d = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) 1arr2d[[0,1], :] array([[1, 2, 3, 4], [5, 6, 7, 8]]) 1arr2d[:, [1,3]] array([[ 2, 4], [ 6, 8], [10, 12]]) 3. Boolean 인덱싱 조건 필터링을 통하여 Boolean값을 이용한 색인 1arr = np.array([1, 2, 3, 4, 5, 6, 7]) 123arr2d = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) 3-1. True와 False값으로 색인하기 boolean index의 수가 꼭 array의 index와 같아야 됨! 1myTrueFalse = [True, False, True] 1arr[myTrueFalse] --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-43-9c52b39d81ae&gt; in &lt;module&gt; ----&gt; 1 arr[myTrueFalse] IndexError: boolean index did not match indexed array along dimension 0; dimension is 7 but corresponding boolean dimension is 3 1myTrueFalse = [True, False, True, False, True, False, True] 1arr[myTrueFalse] array([1, 3, 5, 7]) 3-2. 조건필터 조건 연산자를 활용하여 필터를 생성할 수 있다 1arr2d array([[ 1, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12]]) 1arr2d &gt; 2 # \"2보다 크다\"라는 조건의 만족여부에 따라 Boolean index 생성 array([[False, False, True, True], [ True, True, True, True], [ True, True, True, True]]) 위 Boolean index를 다시 array에 적용하여 해당 부분을 추출: arr2d[조건필터] 1arr2d[arr2d &gt; 2] # 1차원 array로 반환 array([ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) 1arr2d[arr2d &lt; 5] array([1, 2, 3, 4]) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"https://hyemin-kim.github.io/tags/Numpy/"}]},{"title":"Python >> Numpy - (1) Numpy. array","slug":"S-Python-Numpy1","date":"2020-05-18T15:07:32.000Z","updated":"2020-06-11T17:09:39.042Z","comments":true,"path":"2020/05/19/S-Python-Numpy1/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/19/S-Python-Numpy1/","excerpt":"Numpy개요. Numpy import하기. nd array 생성. array에서의 데이터 타입","text":"Numpy개요. Numpy import하기. nd array 생성. array에서의 데이터 타입 목록 1. Numpy 개요 1-1. Numpy이란? 1-2. 별칭 - np 1-3. array (배열) 1-4. shape(차원) &amp; axis(축) 2. Numpy import하기 2-1. 별칭 (alias) 지정하기 (항상 해주세요!) 3. ndarray 생성하기 – \"np.array([…])\" 3-1. list로 부터 생성하기 – “np.array(list_name)” 3-2. shape확인하기 – “array_name .shape” 4. array에서의 data type 4-1. list에서의 data type 4-2. array에서의 data type case 1. int와 float타입이 혼재된 경우 case 2. int와 float 타입이 혼재되었으나, dtype을 지정한 경우 case 3. int / float 와 str 타입이 혼재된 경우 case 4. int와 str 타입이 혼재되어 있고 dtype이 int로 지정한 경우 1. Numpy 개요 1-1. Numpy이란? Numpy: 수학, 과학 계산용 패키지 ​ 1-2. 별칭 - np 1import numpy as np 1-3. array (배열) 배열: 여러 값들의 그룹 &lt; 1차원 배열 &gt; numpy.array([1, 2, 3, 4]) &lt; 2차원 배열 &gt; numpy.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) &lt; n차원 배열 &gt; (nd array: n dimention array) 1-4. shape(차원) &amp; axis(축) shape은 차원의 수 를 확인 (3, ) =&gt; 3 X 1의 배열 (4,3) =&gt; 4 X 3의 배열 (2,5,3) =&gt; 2 X 5 X 3의 배열 axis는 기준이 되는 축 axis는 앞에서 부터 0, 1, 2… nd array의 축: axis 0, axis 1, axis 2, … axis n 2. Numpy import하기 1import numpy 1numpy &lt;module 'numpy' from 'D:\\\\Anaconda\\\\lib\\\\site-packages\\\\numpy\\\\__init__.py'&gt; 2-1. 별칭 (alias) 지정하기 (항상 해주세요!) 1import numpy as np 1np &lt;module 'numpy' from 'D:\\\\Anaconda\\\\lib\\\\site-packages\\\\numpy\\\\__init__.py'&gt; 3. ndarray 생성하기 – \"np.array([…])\" 1arr = np.array([1,2,3,4], dtype=int) 1arr # 주의: list와 다름 array([1, 2, 3, 4]) 1[1, 2, 3, 4] # list [1, 2, 3, 4] 1type(arr) numpy.ndarray 3-1. list로 부터 생성하기 – “np.array(list_name)” 1mylist1 = [1, 2, 3, 4] 12mylist2 = [[1, 2, 3, 4], [5, 6, 7, 8]] 1arr1 = np.array(mylist1) 1arr1 array([1, 2, 3, 4]) 1arr2 = np.array(mylist2) 1arr2 array([[1, 2, 3, 4], [5, 6, 7, 8]]) 3-2. shape확인하기 – “array_name .shape” 1arr1.shape (4,) 1arr2.shape (2, 4) 4. array에서의 data type array에서는 list와 다르게 1개의 단일 데이터 타입 만 허용 된다 4-1. list에서의 data type 1mylist = [1, 3.14, '사과', '1234'] 1mylist [1, 3.14, '사과', '1234'] 1mylist[0] 1 1mylist[2] '사과' 4-2. array에서의 data type case 1. int와 float타입이 혼재된 경우 int와 float타입이 혼재된 경우 int(정수)가 float(실수)로 바꿔진다 1arr = np.array([1, 2, 3, 3.14]) 1arr # 정수가 실수로 바꿔진다 array([1. , 2. , 3. , 3.14]) ​ case 2. int와 float 타입이 혼재되었으나, dtype을 지정한 경우 int와 float 타입이 혼재되었으나, dtype가 int로 지정된 경우, float의 앞에 정수 부분만 보류된다 1arr = np.array([1, 2, 3, 3.14], dtype = int) 1arr array([1, 2, 3, 3]) case 3. int / float 와 str 타입이 혼재된 경우 int / float 와 float타입이 혼재된 경우 int(정수)가 str(문자열)로 바꿔진다 1arr = np.array([1, 3.14, '사과', '1234']) 1arr array(['1', '3.14', '사과', '1234'], dtype='&lt;U32') 1arr[0] + arr[1] #str로 되어버려서 숫자의 사치연산이 안됨 '13.14' case 4. int와 str 타입이 혼재되어 있고 dtype이 int로 지정한 경우 (1) 문자내용인 str이 존재한 경우 error 발생 1arr = np.array([1, 3.14, '사과', '1234', '5.8'], dtype = int) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-50-88e75a912236&gt; in &lt;module&gt; ----&gt; 1 arr = np.array([1, 3.14, '사과', '1234', '5.8'], dtype = int) ValueError: invalid literal for int() with base 10: '사과' (2) 실수(float)내용인 str이 존재한 경우도 error발생 1arr = np.array([1, 3.14, '1234', '5.8'], dtype = int) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-52-98017763e514&gt; in &lt;module&gt; ----&gt; 1 arr = np.array([1, 3.14, '1234', '5.8'], dtype = int) ValueError: invalid literal for int() with base 10: '5.8' (3) 정수(int)내용인 str만 존재한 경우 해당 str이 자동으로 int로 바꿔짐 1arr = np.array([1, 3.14, '1234'], dtype = int) 1arr array([ 1, 3, 1234]) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"https://hyemin-kim.github.io/tags/Numpy/"}]},{"title":"Python 기초문법 - (6) Package","slug":"S-Python-base6","date":"2020-05-16T04:52:05.000Z","updated":"2020-06-11T17:10:50.910Z","comments":true,"path":"2020/05/16/S-Python-base6/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/16/S-Python-base6/","excerpt":"패키지(Package) 와 import","text":"패키지(Package) 와 import 목록 1. 패키지와 모듈 그리고 함수의 관계도 2. 모듈 import 하기 3. 패키지 에서 import하기 4. 별칭 (alias) 지어주기 5. 앞으로 자주 사용할 패키지, 모듈 미리보기 패키지(Package) 와 import 1. 패키지와 모듈 그리고 함수의 관계도 함수들이 뭉쳐진 하나의 .py파일 안에 이루어진 것을 모듈이라고 한다 여러 개의 모듈을 그룹화 하면 패키지가 된다 패키지는 종종 라이브러비라고도 불린다 123from IPython.display import Image# 출척: pythonstudy.xyzImage('http://pythonstudy.xyz/images/basics/python-package.png') 2. 모듈 import 하기 import 하는 방법 .py (파이썬 파일 확장자)로 된 파일을 우리는 모듈 이라고 한다, import 구문을 통해 해당 파일을 불러올 수 있다 1import pandas 위의 코드는 pandas라는 모듈을 우리가 불러오겠다라는 의미이다 3. 패키지 에서 import하기 패키지 안에서 하나의 모듈을 불러온다 1from pandas import DataFrame # pandas라는 패키지 안에서 DataFrame이라는 모듈을 불러온다 1DataFrame() # 모듈 DataFrame사용 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 통째로 패키지나 모듈을 불러온다 1import pandas 1pandas.DataFrame() # DataFrame이라는 모듈을 사용하기 위해서는 .을 찍고 이어서 쓰면 됨 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 4. 별칭 (alias) 지어주기 pandas라는 패키지 이름이 너무 길기 때문에 우리는 약어로 줄여쓸 수 있다. 보통 pd를 보편적으로 많이 사용한다. 줄여서 별명을 지어줄 때는 as를 붙혀준다 1import pandas as pd 1pd.DataFrame() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 5. 앞으로 자주 사용할 패키지, 모듈 미리보기 1234import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as sns numpy: 과학계산을 위한 패키지 pandas: 데이터 분석을 할 때 가장 많이 쓰이는 패키지 matplotlib: 시각확를 위한 패키지 seaborn: 시각화를 위한 패키지 (matplotlib을 더 쉽게 사용할 수 있도록 도와주는 패키지) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Python_Base","slug":"Python-Base","permalink":"https://hyemin-kim.github.io/tags/Python-Base/"}]},{"title":"Python 기초문법 - (5) List Comprehension. 문자열","slug":"S-Python-base5","date":"2020-05-13T16:37:58.000Z","updated":"2020-06-11T17:10:41.561Z","comments":true,"path":"2020/05/14/S-Python-base5/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/14/S-Python-base5/","excerpt":"List Comprehension (List에 조건필터를 적용). 문자열을 가지고 노는 방법.","text":"List Comprehension (List에 조건필터를 적용). 문자열을 가지고 노는 방법. 목록 1. List Comprehension (파이썬 고유의 아름다운 문법) 1-1. list comprehension 조건필터 1-2. [STEP 1] list를 만들어야 하니 일단 꺾쇠[ ]를 씌운다 1-3. [STEP 2] 조건 필터를 걸어 준다 1-4. [응용 STEP] 변수 값을 가공할 수도 있다 2. 문자열(string)을 가지고 놀기 2-1. 문자의 길이 2-2. 문장 쪼개기 – “.split” 2-3. 대문자 / 소문자로 만들기 – “.upper” / “.lower” 2.4. ~로 시작하는, ~로 끝나는 – “.startswith” , “.endswith” 2-5. 바꾸기 – “.replace(‘바꿀 대상, 바꿔야할 값’)” 2-6. 불필요한 공백 제거하기 – “.strip” 1. List Comprehension (파이썬 고유의 아름다운 문법) for ~ in 구조를 기본적으로 가지고 있다 List Comprehension 이니까 당연히 List를 사용한다 [실제 사례 연구] mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 이라는 list를 만들어 주고 우리는 이 중 짝수만 출력하고 싶으면 아래와 같이 쓸 수 있다: 1mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 123for i in mylist: if i % 2 == 0: print(i) 2 4 6 8 10 그럼 mylist에서 짝수만 뽑아서 list로 만들어 주고 싶다면: 12345678mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]even = []for i in mylist: if i % 2 == 0: even.append(i)print(even) [2, 4, 6, 8, 10] 이렇게 for in 문으로 해줄 수 있다. 하지만, 우리는 list comprehension을 통해 더욱 쉽게 해결 할 수 있다!! 1-1. list comprehension 조건필터 1mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 아래 문법이 바로 list comprehension 이다. 한 줄로 해결해 버리는 것이 매력임! 1even = [i for i in mylist if i % 2 == 0] 1even [2, 4, 6, 8, 10] 1-2. [STEP 1] list를 만들어야 하니 일단 꺾쇠[ ]를 씌운다 꺾쇠 안에 반복문이 들어간다 반복문을 돌면서 return 된 i값을 list에 넣는 원리이기 때문에 for구분 앞에 i를 써준다 1even = [i for i in mylist] 1even [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 1-3. [STEP 2] 조건 필터를 걸어 준다 [i for i in mylist (이곳에 조건문)] 1[i for i in mylist if i % 2 == 0] [2, 4, 6, 8, 10] 이것을 변수에 다시 할당해주면 끝! 1even = [i for i in mylist if i % 2 == 0] 1even [2, 4, 6, 8, 10] 1-4. [응용 STEP] 변수 값을 가공할 수도 있다 예를 들어: mylist의 모든 값에 +2를 하고 다시 even이라는 list에 저장하고 싶다면 1mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 1even = [i+2 for i in mylist] 1even [3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 2. 문자열(string)을 가지고 놀기 2-1. 문자의 길이 1a = 'banana' 1len(a) 6 1a = 'banana pen' 1len(a) # 공백도 count된다 10 1b = '한글' 1len(b) 2 1b = '한글 바나나' 1len(b) 6 2-2. 문장 쪼개기 – “.split” split은 문장을 특정 규칙에 의해 쪼개 주는 기능을 한다 명령어: 변수명.split(‘쪼개는 기준’) 쪼개는 기준이 설정되어 있지 않으면 그냥 '빈칸’으로 인식된다 1a = 'This is a pen' 1a.split(' ') ['This', 'is', 'a', 'pen'] 1a.split() ['This', 'is', 'a', 'pen'] 1b = 'This-is-a-pen' 1b.split('-') ['This', 'is', 'a', 'pen'] return된 값을 list형식으로 저장한다 1aa = a.split(' ') 1aa ['This', 'is', 'a', 'pen'] 1aa[0] 'This' 1aa[2] 'a' 1aa[0] + aa[2] 'Thisa' 1c = '한글은 어떻게 될까요?' 1c.split() ['한글은', '어떻게', '될까요?'] 2-3. 대문자 / 소문자로 만들기 – “.upper” / “.lower” 1a = 'My name is hyemin' 1a.upper() 'MY NAME IS HYEMIN' 1a.lower() 'my name is hyemin' 1b = '한글엔 대소문자가 없어요ㅠ' 1b.upper() '한글엔 대소문자가 없어요ㅠ' 1b.lower() '한글엔 대소문자가 없어요ㅠ' 2.4. ~로 시작하는, ~로 끝나는 – “.startswith” , “.endswith” 123a = '01-sample.png'b = '02-sample.jpg'c = '03-sample.pdf' 1a.startswith('01') True 1a.endswith('.jpg') False 1b.endswith('.jpg') True 조건(혹은 형식)에 맞는 파일을 추출하고 싶을 때: 1mylist = [a, b] 123for file in mylist: if file.endswith('jpg'): print(file) 02-sample.jpg 2-5. 바꾸기 – “.replace(‘바꿀 대상, 바꿔야할 값’)” [예] file형식을 바꾸고 싶다면: 1a = '01-sample.png' 1a.replace('.png', '.jpg') '01-sample.jpg' 이 때 a의 값이 변하지 않아. 다시 할당 해야 함 1a '01-sample.png' 1a_new = a.replace('.png', '.jpg') # 새로 지정 1a_new '01-sample.jpg' 1a = a.replace('.png', '.jpg') # 덮어쒸우기 1a '01-sample.jpg' 2-6. 불필요한 공백 제거하기 – “.strip” [예] 12a = ' 01-sample.png'b = '01-sample.png' 1a == b False strip은 양 끝 불필요한 공백을 제거해 줌. 1a.strip() '01-sample.png' 1a.strip() == b True document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Python_Base","slug":"Python-Base","permalink":"https://hyemin-kim.github.io/tags/Python-Base/"}]},{"title":"Python 기초문법 - (4) 비교/논리 연산자. 조건문. 반복문","slug":"S-Python-base4","date":"2020-05-13T08:25:46.000Z","updated":"2020-06-11T17:10:35.405Z","comments":true,"path":"2020/05/13/S-Python-base4/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/13/S-Python-base4/","excerpt":"비교연산자. 조건문. 논리연산자. 반복문","text":"비교연산자. 조건문. 논리연산자. 반복문 목록 1. 비교연산자 1-1. 대소비교 &gt;, &gt;=, &lt;, &lt;= 1-2. 같다 == 1-3. 같지 않다 != 2. 조건문 2-1. 개념 2-2. if 2-3. else 2-4. elif 2-5. 1이나 0은 참이나 거짓을 표현하기도 한다 3. 논리 연산자 (and, or) 3-1. and 3-2. or 4. 반복문 4-1. 반복문이란? 4-2. for 와 in을 활용하자! 4-3. 반복문에서 짝수만 출력하려면? (continue구문) 4-4. 조건을 충족시 순환에서 빠져나와보자! (break구문) 1. 비교연산자 비교 연산자는 주로 대소비교를 할 때 사용한다. 1-1. 대소비교 &gt;, &gt;=, &lt;, &lt;= 11 &gt; 2 False 110 &gt;= 10 True 19 &lt; 10 True 18 &lt;= 7 False 1-2. 같다 == 주의: = 는 대입연산자. == 는 비교연산자 중의 “같다” 숫자형 &amp; 문자형 모두 비교 가능 12 = 2 File \"&lt;ipython-input-6-a8e553549e25&gt;\", line 1 2 = 2 ^ SyntaxError: can't assign to literal 12 == 2 True 12 == 3 False 1\"나\" == \"나\" True 1-3. 같지 않다 != 숫자형 &amp; 문자형 모두 비교 가능 12 != 2 False 12 != 3 True 1\"나\" != \"너\" True 2. 조건문 2-1. 개념 주어진 조건이 참인 경우 그 다음 내가 규칙(로직)을 실행하는 개념이다 2-2. if if는 어떤 조건이 성립한다면 ~이라는 의미 if구문 끝에는 반드시 콜론( : )이 있어야 함 12if 5 &gt; 3: print('참') 참 if구문 뒤에 indent가 있는 명령어는 if조건이 성립하면 실행 indent가 없으면 if의 성립여부와 무관하여 무조건 실행 12345if 5 &gt; 3: print('참') print('참') print('끝') 참 참 끝 12345if 5 &lt; 3: print('참') print('참') print('끝') # 앞에 indent가 없으면 if의 성립여부와 무관하여 실행 끝 2-3. else else는 if 조견 후에 따라오면, if가 아닌 경우에 실행 됨 1234if 5 &lt; 3: print(\"성립한다\")else: print(\"성립하지 않은다\") 성립하지 않은다 else는 꼭 if랑 같이 써야함. 단독으로 실행할 수 없음 12else: print(\"성립하지 않은다\") File \"&lt;ipython-input-22-6c0f4debaa4b&gt;\", line 1 else: ^ SyntaxError: invalid syntax 2-4. elif elif구문은 3가지 이상 문기(조건)의 동작을 수행할 때 사용 123456if 3 &gt; 5: print('if 구문')elif 3 &lt; 4: print('elif 구문')else: print('이것도 저것도 아니다') elif 구문 그럼, elif구문이 참인 여러 구문을 나열 했을 때는 어떻게 될까? 12345678910if 3 &gt; 5: print('if 구문')elif 3 &lt; 4: print('elif 1 구문')elif 3 &lt; 5: print('elif 2 구문')elif 3 &lt; 6: print('elif 3 구문')else: print('이것도 저것도 아니다') elif 1 구문 elif구문이 참인 여러 구문을 나열 했을 때는 첫번째 참인 elif구문만 실행됨 2-5. 1이나 0은 참이나 거짓을 표현하기도 한다 1234if 1: print('참')else: print('거짓') 참 1234if 0: print('참')else: print('거짓') 거짓 3. 논리 연산자 (and, or) and나 or조건은 두 가지 이상 조건을 다룰 때 활용한다 3-1. and and 조건은 모두 만족할 때 참으로 인식한다 1True and True and True True 1True and False and True False 1234if (0 &lt; 1) and (0 &lt; 2): print('모두 참')else: print('거짓') 모두 참 1234if (0 &lt; 1) and (0 &gt; 2): print('모두 참')else: print('거짓') 거짓 3-2. or or조건은 조건 중 하나라도 만족할 때 참으로 인식한다 1True or False or False True 1False or False or False False 1234if (0 &lt; 1) or (0 &gt; 2): print('하나라도 참')else: print('모두 거짓') 하나라도 참 1234if (0 &gt; 1) or (0 &gt; 2): print('하나라도 참')else: print('모두 거짓') 모두 거짓 4. 반복문 4-1. 반복문이란? 일을 반복 처리 해준다는 것 대상은 반드시 list, dict, set등 집합이어야 한다 [예] 반복문 쓰지 않을 때: 1mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] mylist에 들어 닜는 모든 값들을 출력하려고 한다면? 123456print(mylist[0])print(mylist[1])print(mylist[2])print('...')print(mylist[8])print(mylist[9]) 1 2 3 ... 9 10 반복문은 노가다를 획기적으로 줄여주는 방법이다! 4-2. for 와 in을 활용하자! [기본 문법] for 지정한 변수명 in [꺼내올 집합]: 명령어 1mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 12for i in mylist: print(i) 1 2 3 4 5 6 7 8 9 10 4-3. 반복문에서 짝수만 출력하려면? (continue구문) 1mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 방법1: 123for i in mylist: if i % 2 == 0: print(i) 2 4 6 8 10 방법2: continue구문을 사용하면 조건이 충족할 때 아래 명령어를 SKIP하고 다시 다음 순환으로 넘어간다 1234for i in mylist: if i % 2 == 1: continue print(i) 2 4 6 8 10 4-4. 조건을 충족시 순환에서 빠져나와보자! (break구문) 1mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] i가 6 이상이면 STOP 1234for i in mylist: if i &gt;= 6: # i &gt; 6 이면 6까지 출력한다 break print(i) 1 2 3 4 5 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Python_Base","slug":"Python-Base","permalink":"https://hyemin-kim.github.io/tags/Python-Base/"}]},{"title":"Python 기초문법 - (3) 함수","slug":"S-Python-base3","date":"2020-05-13T07:16:31.000Z","updated":"2020-06-11T17:10:29.795Z","comments":true,"path":"2020/05/13/S-Python-base3/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/13/S-Python-base3/","excerpt":"함수의 기초","text":"함수의 기초 목록 1. 함수란 무엇일까? 2. 함수 정의: def (define) 3. 함수는 값을 return할 수 있고, 안해도 됨 4. parameter가 여러 개 있으면, 함수에 넘겨 줄 때 순서가 중요 함수 1. 함수란 무엇일까? 반복적으로 사용되는 부문을 묶어서, 재사용 가능하도록 만들어 주는 것 함수에는 **들어가는 놈 (input)**이 있고, **나오는 놈 (output 혹은 return)**이 있다. 전해진 로직(규칙)에 따라, input -&gt; output으로 효율적으로 바꿔주는 역할을 한다 [예시] 함수 없이 계산할 때 123a = 1b = 2c = 3 1(a + b) * c 9 123a = 2b = 2c = 3 1(a + b) * c 12 함수로 변경 후 12def func(a, b, c): return (a + b) * c 1func(1, 2, 3) 9 1func(2, 2, 3) 12 2. 함수 정의: def (define) 사용법: def 함수이름 (parameter1, parameter2, parameter3…): parameter는 함수로 부터 넘겨 받은 변수 또는 값이다 끝에 콜론 ( : ) 빼먹지 않음에 주의 해야함! 12def myfunc(var1): print(var1) # 실행 명령 1myfunc(\"안녕하세요\") 안녕하세요 3. 함수는 값을 return할 수 있고, 안해도 됨 리턴이 없는 경우 12def my_func(a, b): print(a, b) 1my_func(1,10) 1 10 리턴이 있는 경우 123def my_func(a, b): s = a + b return s 1my_func(2, 3) 5 리턴이 있는 경우는 변수에 값을 다시 할당 할 수 있음 1result = my_func(2,3) 1print(result) 5 1print(result + 10) 15 4. parameter가 여러 개 있으면, 함수에 넘겨 줄 때 순서가 중요 12def my_func(a, b, c): return (a + b) * c 123a = 10b = 20c = 3 1(a + b) * c 90 1my_func(a, b, c) 90 1my_func(c, b, a) # (c + b) * a = (3 + 20) * 10 230 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Python_Base","slug":"Python-Base","permalink":"https://hyemin-kim.github.io/tags/Python-Base/"}]},{"title":"Python 기초문법 - (2) 집합 형태의 데이터 타입","slug":"S-Python-base2","date":"2020-05-12T17:26:49.000Z","updated":"2020-06-11T17:10:22.797Z","comments":true,"path":"2020/05/13/S-Python-base2/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/13/S-Python-base2/","excerpt":"","text":"집합 형태의 데이터 타입 1. list (순서가 있는 집합) 1-1. [ ] 형테로 표현 1-2. 값 추가 – “.append( )” 1-3. 값 제거 – “.remove” / “.clear” 1-4. 인덱싱(Indexing) -&gt; 색인 1-5. 인덱스로 접근하여 값 바꾸기 1-6. 길이 파악하기 2. tuple (순서가 있는 집합, 읽기 전용) 2-1. ( ) 형태로 표현 2-2. 읽기 전용이라 “값 추가”, “값 제거”, “값 바꾸기” 모두 안됨 2-3. 길이 파악하기 3. set (순서 X, 중복 X) 3-1. set의 할당: set() 3-2. 값 추가 – \".add \" 3-3. 값 제거 – “.remove” / “.clear” 4. dict (사전형 집합, key와 value 쌍) 4-1. { } 형태로 표헌 4-2. 값 추가 (key와 value 모두 지정) 4-3. 값 바꾸기 4-4. 값 제거 – “.pop” / “.clear” 4-5. 길이 파악하기 짐합 형태의 데이터 타입 list (순서 O, 짐합) tuple (순서 X, 읽기 전용 집합) set (순서 X, 중복 X 집합) dict (key, value로 이루어진 사전형 집합) 1. list (순서가 있는 집합) 1-1. [ ] 형테로 표현 1mylist = [] 1mylist [] 1type(mylist) list 12mylist = [1,2,3,4,5]mylist [1, 2, 3, 4, 5] 12mylist2 = [5,4,3,2,1] # 순서가 있다mylist2 [5, 4, 3, 2, 1] 1-2. 값 추가 – “.append( )” 12mylist = []mylist [] 12mylist.append(1)mylist [1] 123mylist.append(2)mylist.append(3)mylist [1, 2, 3] .append 함수 안에 1 argument만 들어갈 수 있다 12mylist.append(4,5)mylist --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-22-6f00703728b8&gt; in &lt;module&gt; ----&gt; 1 mylist.append(4,5) 2 mylist TypeError: append() takes exactly one argument (2 given) 1-3. 값 제거 – “.remove” / “.clear” 부분 제거 – \".remove\" 1mylist [1, 2, 3] 12mylist.remove(1)mylist [2, 3] 전부 제거 – \".clear\" 1mylist.clear() 1mylist [] 같은 값이 여러 개 포함되어 있을 때의 제거 순서 앞에서 부터 순차적으로 제거 됨 12mylist = [1,2,3,1,2,3]mylist [1, 2, 3, 1, 2, 3] 12mylist.remove(1)mylist [2, 3, 1, 2, 3] 12mylist.remove(1)mylist [2, 3, 2, 3] 1-4. 인덱싱(Indexing) -&gt; 색인 인덱스는 0번 부터 시작한다 1mylist = [1,2,3,4] # 인덱스: 0번, 1번, 2번, 3번 1mylist[0] 1 1mylist[3] 4 1mylist[4] --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-34-88b11041aa4f&gt; in &lt;module&gt; ----&gt; 1 mylist[4] IndexError: list index out of range 인덱스가 음수일 경우: 뒤에서 부터 n번째 1mylist[-1] 4 1-5. 인덱스로 접근하여 값 바꾸기 1mylist [1, 2, 3, 4] 1mylist[0] 1 1mylist[0] = 100 1mylist [100, 2, 3, 4] 1-6. 길이 파악하기 1mylist [100, 2, 3, 4] 1len(mylist) # length 4 2. tuple (순서가 있는 집합, 읽기 전용) 2-1. ( ) 형태로 표현 1mytuple = (1,2,3,4,5) 2-2. 읽기 전용이라 “값 추가”, “값 제거”, “값 바꾸기” 모두 안됨 1mytuple.append(1) # 읽기 전용이라 값을 추가할 수 없음 --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-45-d0f55ea1e3f6&gt; in &lt;module&gt; ----&gt; 1 mytuple.append(1) # 읽기 전용이라 값을 추가할 수 없음 AttributeError: 'tuple' object has no attribute 'append' 1mytuple.remove(1) --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-46-05a40423345b&gt; in &lt;module&gt; ----&gt; 1 mytuple.remove(1) AttributeError: 'tuple' object has no attribute 'remove' 1mytuple[0] = 100 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-48-4e527888818c&gt; in &lt;module&gt; ----&gt; 1 mytuple[0] = 100 TypeError: 'tuple' object does not support item assignment 2-3. 길이 파악하기 1mytuple (1, 2, 3, 4, 5) 1len(mytuple) 5 3. set (순서 X, 중복 X) 3-1. set의 할당: set() 12myset = set()myset set() 1type(myset) set 3-2. 값 추가 – \".add \" 1234myset.add(1)myset.add(2)myset.add(3)myset {1, 2, 3} 1234567myset.add(1) myset.add(2)myset.add(3)myset.add(1) # 중복된 값을 한번만 기록myset.add(2)myset.add(3)myset {1, 2, 3} 12myset.add(4)myset {1, 2, 3, 4} 3-3. 값 제거 – “.remove” / “.clear” 부분 제거 – \".remove\" 1myset {1, 2, 3, 4} 1myset.remove(3) 1myset {1, 2, 4} 전부 제거 – \".clear\" 1mylist.clear() 1mylist [] 4. dict (사전형 집합, key와 value 쌍) 4-1. { } 형태로 표헌 1mydict = dict() 1mydict {} 1type(mydict) dict 4-2. 값 추가 (key와 value 모두 지정) mydict [ \" key \" ] = value key는 문자형 (str) / 숫자형 (int &amp; float) 모두 가능 1mydict[\"apple\"] = 123 1mydict {'apple': 123} 1mydict[\"apple\"] 123 1mydict[0] = 2 1mydict {'apple': 123, 0: 2} 1mydict[0] 2 1mydict[3.14] = 1 1mydict {'apple': 123, 0: 2, 3.14: 1} 1mydict[3.14] 1 4-3. 값 바꾸기 새 값을 해당 key에 할당하기 1mydict[\"apple\"] = \"hello\" 1mydict {'apple': 'hello', 0: 2, 3.14: 1} 4-4. 값 제거 – “.pop” / “.clear” 부분 제거 – \".pop\" 1mydict.pop('apple') 'hello' 1mydict {0: 2, 3.14: 1} 1mydict.pop(0) 2 1mydict {3.14: 1} 전부 제거 – \".clear\" 1mydict.clear() 1mydict {} 4-5. 길이 파악하기 123mydict[\"apple\"] = 123mydict[0] = 2mydict[3.14] = 1 1mydict {'apple': 'hello', 0: 2, 3.14: 1} 1len(mydict) 3 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Python_Base","slug":"Python-Base","permalink":"https://hyemin-kim.github.io/tags/Python-Base/"}]},{"title":"Python 기초문법 - (1) 출력. 데이터 타입. 데이터의 응용","slug":"S-Python-base1","date":"2020-05-11T17:18:11.000Z","updated":"2020-06-11T17:10:13.174Z","comments":true,"path":"2020/05/12/S-Python-base1/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/12/S-Python-base1/","excerpt":"출력. 변수. 데이터 타입. 데이터의 응용. 데이터 타입의 변환.","text":"출력. 변수. 데이터 타입. 데이터의 응용. 데이터 타입의 변환. 목록 1. 출력 (print) print( ) 함수 2. 변수와 대입 2-1. 변수의 이름 【가능한 경우】 【불가한 경우】 2-2. 변수의 대입 2-3. 변수의 출력 3. 데이터 타입 3-1. int(정수) 3-2. float(실수) 3-3. str 혹은 object (문자열) 3-4. bool (참/거짓) 3-5. 아무것도 아닌 None타입도 있다 4. 데이터의 응용 4-1. 사칙 연산자 4-2. 문자열의 연결 5. 데이터 타입 변환 5-1. 문자열로 변환: “str( ) 함수” or “따움표” 5-2. 정수로 변환: \" int( ) 함수\" 5-3. 실수로 변환: “float( ) 함수” 1. 출력 (print) print( ) 함수 숫자를 출력할 때 따움표(’ ’ or \" \") 필요없음 문자를 출력할 때 따움표 필요 ’ ’ 와 \" \" 차이없음 ‘’’ ‘’’ 를 사용하면 출력시 “줄 바꿈” 형식이 보류될 수 있음 1print(1) 1 1print(1+2) 3 1print('안녕하세요') 안녕하세요 1print(\"반갑습니다\") 반갑습니다 1234print('''안녕하세요,반갑습니다.''') 안녕하세요, 반갑습니다. 2. 변수와 대입 2-1. 변수의 이름 【가능한 경우】 case 1. 알파벳 1a = 1 1A = 1 case 2. 알파벳 + 숫자 1a1 = 1 case 3. 알파벳 + 언더바(_) 1a_ = 1 case 4. 언더바(_) + 알파벳 1_a = 1 【불가한 경우】 case 1. 언더바(_)를 제외한 특수문자 1* = 1 File \"&lt;ipython-input-23-6d0163a9fd4c&gt;\", line 1 * = 1 ^ SyntaxError: invalid syntax case 2. 알파벳 + 언더바를 제외한 특수문자 1a$ = 1 File \"&lt;ipython-input-25-2501fc576aab&gt;\", line 1 a$ = 1 ^ SyntaxError: invalid syntax case 3. 변수의 이름 사이의 공백 1a b = 1 File \"&lt;ipython-input-26-2bab97d7970c&gt;\", line 1 a b = 1 ^ SyntaxError: invalid syntax 2-2. 변수의 대입 변수 값을 부여할 때 \"=\"를 사용한다 1a = 1 2-3. 변수의 출력 print() 구문 사이에 값을 직접 입력하면, 바로 값이 출력됨. 1print(123) # 숫자는 \"\" 필요없음 123 1print(\"text\") # 문자는 \"\" 필요함 text print()구분 사이에 변수 이름을 입력하면, 변수의 값이 출력됨. 12a = 123print(a) 123 12b = \"text\"print(b) text 3. 데이터 타입 데이터 type: 1. int(정수) 2. float(실수) 3. str(문자열) 4. bool(참/거짓) 3-1. int(정수) 1a = 1 1type(a) int 1print(a) 1 코딩에서 1은 참으로 취급, 0은 거짓으로 취급 다음 코딩으로 진단해보자: 1234if 1: print('1은 참으로 취급')else: print('1은 거짓부렁이') 1은 참으로 취급 1234if 0: print('0은 참으로 취급')else: print('0은 거짓부렁이') 0은 거짓부렁이 1234if 123: print('123은 참으로 취급')else: print('123은 거짓부렁이') 123은 참으로 취급 [0 이외의 정수 다 참으로 취급] 3-2. float(실수) 1a = 3.14 1type(a) float 1print(a) 3.14 3-3. str 혹은 object (문자열) 문자열은 반드시 ’ ’ 혹은 \" \" 로 묶어야 함 1word = '안녕하세요' 1type(word) str 1print(word) 안녕하세요 1word = \"안녕하세요\" 1type(word) str 1print(word) 안녕하세요 ’\" \"’ 를 사용하면 출력시 “줄 바꿈” 형식이 보류될 수 있음 1234print('''안녕하세요,반갑습니다.''') 안녕하세요, 반갑습니다. 3-4. bool (참/거짓) 참: True 거짓: False 1a = True 1a True 1type(a) bool 1b = False 1b False 1type(b) bool 11 == True True 10 == False True 1123 == True False 1 이외의 정수는 조건절에서 참으로 인식되지만, bool과 비교할 때 참이 아니다 3-5. 아무것도 아닌 None타입도 있다 Null값을 넣는다고도 한다. Null: Nullify (무효화하다) – 사전상 의미 Python에서는 None 입니다 1a = None 1print(a) None 1type(a) NoneType 조건문에 None이라면? 1234if None: print(\"None은 참으로 취급\")else: print(\"None은 거짓부렁이\") None은 거짓부렁이 4. 데이터의 응용 4-1. 사칙 연산자 연산자 의미 예 + 더하기 2 + 1 -&gt; 3 - 빼기 1 - 2 -&gt; -1 * 곱하기 1 * 2 -&gt; 2 / 나누기 1 / 2 -&gt; 0.5 % 몫 5 % 2 -&gt; 2 // 나머지 5 // 2 -&gt; 1 ** 멱 2**3 -&gt; 8 4-2. 문자열의 연결 여러 개 문자열을 \"+\"을 통해 연결할 수 있다 12345subject = \"나는 \"object = \"치킨을 \"verb = \"좋아한다\"print(subject + object + verb) 나는 치킨을 좋아한다 하지만 문자열(str)과 숫자(int &amp; float)는 직접 연결할 수 없다 1234567a = \"내가 \"b = \"친구랑 \"c = 12d = \"시에 \"e = \"보기로 했다\"print(a + b + c + d + e) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-82-34cd0f9ce519&gt; in &lt;module&gt; 5 e = \"보기로 했다\" 6 ----&gt; 7 print(a + b + c + d + e) TypeError: can only concatenate str (not \"int\") to str 이 때는 데이터 타입을 변환할 필요가 있다 5. 데이터 타입 변환 5-1. 문자열로 변환: “str( ) 함수” or “따움표” 1type(6) int 1type(str(6)) str 1type('6') str 1type(3.14) float 1type(str(3.14)) str 1type(\"3.14\") str 12345a = \"내가 \"b = \"친구랑 \"c = 12d = \"시에 \"e = \"보기로 했다\" 1print(a + b + str(c) + d + e) 내가 친구랑 12시에 보기로 했다 1print(a + b + '12' + d + e)a 내가 친구랑 12시에 보기로 했다 5-2. 정수로 변환: \" int( ) 함수\" \"str\" --&gt; “int”: str( ) 안 내용이 정수일 때만 가능 1type(int(\"2\")) int 12number1 = \"2\"number2 = \"3\" 1print(int(number1) + int(number2)) 5 1print(int(\"2.6\")) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-103-f4645c45f771&gt; in &lt;module&gt; ----&gt; 1 print(int(\"2.6\")) ValueError: invalid literal for int() with base 10: '2.6' \"float\" --&gt; “int”: 소수점 버림 1type(int(3.6)) int 1print(int(3.6)) 3 5-3. 실수로 변환: “float( ) 함수” \"str\" --&gt; “float”: str( ) 안 내용이 정수일 때만 가능 1type(float(\"3.14\")) float 1print(float(\"3.14\")) 3.14 \"int\" --&gt; “float”: 소수점 하나 추가 1type(float(178)) float 1print(float(178)) 178.0 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Python_Base","slug":"Python-Base","permalink":"https://hyemin-kim.github.io/tags/Python-Base/"}]},{"title":"利用Git Pages+Hexo搭建博客过程中的参考资料","slug":"Reference","date":"2020-05-07T17:16:53.000Z","updated":"2020-05-22T10:10:51.388Z","comments":true,"path":"2020/05/08/Reference/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/08/Reference/","excerpt":"","text":"博客搭建 bilibili — 超简单易懂的Git入门教程 bilibili — github+hexo搭建个人博客 bilibili — github博客搭建（二）：Markdown语法及hexo主题修改 Git Pages + Jekyll/Hexo搭建自己的博客(最全总结你想知道的都在这里了) 网页配置 &amp; 主题配置 Hexo Usage Documents Hexo Themes default — [Demo] tomotoes — [Demo] / [Documents] Butterfly — [Demo] / [Documents] (应用中) Git Pages + Jekyll/Hexo搭建自己的博客(最全总结你想知道的都在这里了) Hexo主题升级方法（实用！） Markdown渲染 bilibili — github博客搭建（二）：Markdown语法及hexo主题修改 [字体修改方法(17:30)] Markdown在Hexo中的使用实例 [分割线，空行插入方法] Markdown渲染插件 hexo-renderer-markdown-it 插件 快速配置 hexo-renderer-markdown-it [Documents] hexo-renderer-markdown-it-plus （应用中） hexo-renderer-markdown 插入本地图片 markdown插入本地图片小技巧 typora + hexo博客中插入图片（应用中） 其他 记录网站访问量: 不蒜子 hexo博客解决不蒜子统计无法显示问题 设置博客评论： Gitalk申请页面 在个人博客里添加评论系统–Gitalk hexo 使用 gitalk 评论组件的几个注意点 多语言版本: Hexo 巧用 abbrlink 插件实现文章多语言版本 (既然没人帮我，那就)自己弄了个 Hexo 多语言 index 生成插件 更改tag大小写后出现404页面 Hexo 部署到 Github Pages 文件夹大小写问题 更改博客 Front Page 的默认配置 hexo博客Front-matter模板配置 Git &amp; Github bilibili — 【教程】学会Git玩转Github【全】 bilibili — 超简单易懂的Git入门教程 Git与Github的连接与使用 Git和GitHub使用教程 Jupyter Notebook bilibili — python数据分析神器Jupyter notebook快速入门 bilibili —【冷门教学】记笔记神器-jupyter notebook 第二弹 史上最详细、最完全的jupyter notebook使用教程，Python使用者必备！——ipython系列之三 机器学习新手必看：Jupyter Notebook入门指南 Jupyter notebook简介及嵌入Hexo博客中 用 Hexo 搭建个人博客-02：进阶试验（包括添加Jupyter Notebook支持的方法） 如何在你的Jupyter Notebook中使用R语言？ Markdown &amp; Typora bilibili — 二十分钟精通排版神器Markdown Typora官网 [Documents] Typora中下载并安装主题 bilibili — Typora 编辑器 —— 书写即为美学 bilibili — 【软件教程】如何用Typora记笔记？ | 附带Markdown基础教程 Typora设置（中文字体、颜色、行距、内边距等） Markdown中插入本地图片 markdown插入本地图片小技巧 typora + hexo博客中插入图片 在此感谢所有提供了宝贵学习资料的原po主们~ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Usage","slug":"【Study】/Usage","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Usage/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hyemin-kim.github.io/tags/Hexo/"},{"name":"Typora","slug":"Typora","permalink":"https://hyemin-kim.github.io/tags/Typora/"},{"name":"Markdown","slug":"Markdown","permalink":"https://hyemin-kim.github.io/tags/Markdown/"},{"name":"Git","slug":"Git","permalink":"https://hyemin-kim.github.io/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://hyemin-kim.github.io/tags/Github/"},{"name":"Jupyter notebook","slug":"Jupyter-notebook","permalink":"https://hyemin-kim.github.io/tags/Jupyter-notebook/"}]},{"title":"在Hexo博文中添加本地图片的方法（基于Typora编辑器）","slug":"Hexo-Insert-local-images","date":"2020-05-06T12:20:48.531Z","updated":"2020-05-22T07:31:34.789Z","comments":true,"path":"2020/05/06/Hexo-Insert-local-images/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/06/Hexo-Insert-local-images/","excerpt":"当我们想在markdown文档中添加网络图片时，可以使用命令!['图片名称'](图片网络地址)进行实现，然而这条命令却不适用于添加本地图片。本文将介绍在使用Typora编辑器编辑Hexo博文时，向markdown文档中添加本地图片的方法。快来看看吧","text":"当我们想在markdown文档中添加网络图片时，可以使用命令!['图片名称'](图片网络地址)进行实现，然而这条命令却不适用于添加本地图片。本文将介绍在使用Typora编辑器编辑Hexo博文时，向markdown文档中添加本地图片的方法。快来看看吧 【编写博客前】— 进行配置 【编写博客时】— 图片导入方法 【编写博客后】— 图片存档结果 【编写博客前】— 进行配置 建立 资源文件夹(Asset Floder)，用来保存添加到博文中的本地图片 在本地Hexo根目录下的source文件夹中创建一个名为 images 的文件夹 在Typora中设置图片的相对路径 打开Typora的文件 &gt; 偏好设置 &gt; 图像，进行如下设置： 此设置会使source/images文件夹下新增一个与所编辑的markdown文档同名的文件夹，文档中所添加的 本地图片 都将存档于此（即拥有了如下路径：'hexo根目录'/source/images/'md文档名'/'图片名称'）)。 撰写markdown文档时配置 图片根目录 ，使其能够同步到hexo博客中去 撰写博文时，先点击Typora菜单栏中的格式 &gt; 图像 &gt; 设置图片根目录 , 将根目录配置为'hexo根目录'/source。然后再撰写博文。【注：每篇需要添加本地图片的博文都要先进行此步骤】 【编写博客时】— 图片导入方法 直接拖拽 将原本存放于其他本地文件夹中的图片直接拖拽到文档中的相应位置中去 此时图片会被自动存档至生成的同名文件夹'hexo根目录'/source/images/'md文档名'中 文档中图片地址的代码会显示成 自动生成的相对路径，即/images/'md文档名'/'图片名称' 利用相对路径调取 当利用 方法1 插入了至少一张图片时（即已生成同名文件夹时），便可以把接下来要插入的图片复制到此同名文件夹中，在文档中利用相对路径 调取图片： 所使用的命令是：![图片显示名称](/images/'md文档名'/'图片名称') 这里的图片显示名称不必与文件夹中保存的图片名称保持一致，'图片名称'中要记得包含图片格式（例如：tupian.jpg 或 picture.png 等） 【注意】当还没有利用 方法1 插入过图片时（即同名文件夹尚未生成时），不可以自己创建同名文件夹保存图片。亲测不好使！！（.md文档中可以显示，但是hexo博文中无法显示） 【编写博客后】— 图片存档结果 在利用上述方法完成了含有本地图片的markdown博文后，我们的资源文件夹'hexo根目录'/source/images/内最终会显示成什么样子呢？ 每一篇配置了图片根目录的博文（即【编写博客前】的第3步），都会在'hexo根目录'/source/images/文件夹中有一个与文档名称同名的文件夹'hexo根目录'/source/images/'md文档名' 该文件夹中会保存博文编写中曾经添加的所有本地图片 所有的含义是：即使编辑过程中某些本地图片在添加后又被删除了，它们也仍然会保留在文件夹中，即该文件夹会备份你在博文中添加的 所有本地图片历史 本地图片的含义是：这里只会保存插入的本地图片，而不会保存插入的网络图片。尽管在【编写博客前】的第2步配置中，我们也同样勾选了对网络位置的图片应用上述规则。（请原谅我并不知道其中的缘由。。） 就此，在Typora编辑器中编写Hexo博文时，向markdown文档中添加本地图片的方法就介绍完毕啦！快去应用到你的博文中去吧~ 本文参考了yinyoupoet的typora + hexo博客中插入图片 更多关于Typora中插入图片的内容可以参考Typora的官方说明 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Usage","slug":"【Study】/Usage","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Usage/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hyemin-kim.github.io/tags/Hexo/"},{"name":"Typora","slug":"Typora","permalink":"https://hyemin-kim.github.io/tags/Typora/"},{"name":"Markdown","slug":"Markdown","permalink":"https://hyemin-kim.github.io/tags/Markdown/"}]},{"title":"Markdown 常用语法（持续更新）","slug":"Markdown-Syntax","date":"2020-05-03T16:40:07.372Z","updated":"2020-05-22T16:16:06.234Z","comments":true,"path":"2020/05/04/Markdown-Syntax/","link":"","permalink":"https://hyemin-kim.github.io/2020/05/04/Markdown-Syntax/","excerpt":"","text":"Markdown 常用语法 标题 一级标题： “#” + 空格 + “一级标题” 二级标题： “##” + 空格 + “二级标题” 三级标题： “###” + 空格 + “三级标题” …… 以此类推 【最多到6级】 换行 “内容” 末尾 + 2个空格 + Enter 斜体 方法一：“内容”前后加1个 * 号（无空格） 方法二：“内容”前后加1个下划线（无空格） *“内容” * ——&gt; “内容” _ “内容” _ ——&gt; 内容 加粗 方法一：“内容”前后加2个 * 号（无空格） 方法二：“内容”前后加2个下划线（无空格） ** “内容” ** ——&gt; \"内容\" __ “内容” __ ——&gt; “内容” 斜体加粗 “内容”前后加 3 个 * 号 （无空格） “内容” 删除线 ”内容”前后加 2 个波浪线（~） ~~ “内容” ~~ ——&gt; “内容” 高亮 “内容”前后加 2 个 = 号 == “内容” == ——&gt; “内容” 字体，颜色，字号 使用 font 标签 1&lt;font face='Microsift Yahei' color='red' size='6'&gt; 字体，颜色和字号 &lt;/font&gt; 字体，颜色和字号 上标 &amp; 下标 上标：“内容”前后加 1 个 ^ 号 下标：“内容”前后加 1 个 ~ 号 我是 ^ 上标 ^ ——&gt; 我是上标 我是 ~ 下标 ~ ——&gt; 我是下标 引用 “内容”前加 &gt; 号 “内容” 引用号可叠用，&gt;号越多，级数越低 例如：可以使用&gt;, &gt;&gt;, &gt;&gt;&gt; 的形式 一级引用 二级引用 三级引用 文字内容对齐设置 1. 使用div标签： 1&lt;div style=\"text-align: right\"&gt;your-text-here&lt;/div&gt; 居左 居中 居右 2. 使用p标签：(在Jupyter Notebook中不适用) 居中：&lt;center&gt; 内容 &lt;/center&gt; 居左/居右：&lt;p align='left'&gt; 内容 &lt;/p&gt; 居左 居中 居右 插入链接 ​ 中括号内输入“显示的文字”，紧接着小括号内输入“网址链接” ​ 【注意：网站地址需要 http 开头，最好直接复制】 点我进入百度 插入图片 ​ 感叹号 + 中括号内输入“显示的文字”，紧接着小括号内输入“图片链接” ​ 【注意：图片链接非网页的网址栏链接，而是右键“复制图片地址”得到的链接 (Chrome)】 调整图片大小： 1&lt;img src=\"链接\" width=\"宽度(数字or百分比)\" height=\"高度\" alt=\"图片名称\" align=center/left/right&gt; 列表 （1） 有序列表 ​ （序号1+点+空格）+内容+回车 ​ （序号2+点+空格）+内容+回车 ​ （序号3+点+空格）+内容+回车 第一行 第二行 第三行 ​ 【注意】：系统会默认调整有序列表的序列数。即，即使你误输入成了1.，2.，4.，系统也会自动更正为 1.，2.，3. 第一点 第二点 第四点 （2）无序列表 ​ 使用“ + ”+空格+内容 ​ ​ 或者“ - ”+空格+内容 ​ ​ 或者“ * ”+空格+内容 ​ 下一级：前面加 tab 第一章 第二章 第三章 第一节 （3）任务列表 ​ 短横线 + 1 个空格 + 中括号（括号中间带 1 个空格） + 1 个空格 + “内容” [x] 学习python [ ] 学习SQL 添加表格 竖线作为列分界线，换行竖线中间输入短横线作为行分界线 1 2 3 a b c d e f 代码 三个 ` 号，再输入所使用的编程语言 1print(\"Python\") # python 1install.packages(\"ggplot2\") # R语言 插入目录 [Only for Typora] 中括号内输入toc In Hexo: @[toc] (在使用hexo-renderer-markdown-it-plus插件时) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Usage","slug":"【Study】/Usage","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Usage/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://hyemin-kim.github.io/tags/Markdown/"}]}],"categories":[{"name":"【Exercise】","slug":"【Exercise】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Exercise%E3%80%91/"},{"name":"Python","slug":"【Exercise】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Exercise%E3%80%91/Python/"},{"name":"【Study】","slug":"【Study】","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/"},{"name":"Python","slug":"【Study】/Python","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Python/"},{"name":"Usage","slug":"【Study】/Usage","permalink":"https://hyemin-kim.github.io/categories/%E3%80%90Study%E3%80%91/Usage/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hyemin-kim.github.io/tags/Python/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hyemin-kim.github.io/tags/Pandas/"},{"name":"전처리","slug":"전처리","permalink":"https://hyemin-kim.github.io/tags/%EC%A0%84%EC%B2%98%EB%A6%AC/"},{"name":"데이터파악","slug":"데이터파악","permalink":"https://hyemin-kim.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%8C%8C%EC%95%85/"},{"name":"Numpy","slug":"Numpy","permalink":"https://hyemin-kim.github.io/tags/Numpy/"},{"name":"Python_Base","slug":"Python-Base","permalink":"https://hyemin-kim.github.io/tags/Python-Base/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hyemin-kim.github.io/tags/Hexo/"},{"name":"Typora","slug":"Typora","permalink":"https://hyemin-kim.github.io/tags/Typora/"},{"name":"Markdown","slug":"Markdown","permalink":"https://hyemin-kim.github.io/tags/Markdown/"},{"name":"Git","slug":"Git","permalink":"https://hyemin-kim.github.io/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://hyemin-kim.github.io/tags/Github/"},{"name":"Jupyter notebook","slug":"Jupyter-notebook","permalink":"https://hyemin-kim.github.io/tags/Jupyter-notebook/"}]}